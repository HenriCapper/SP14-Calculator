<!DOCTYPE html>
<html>
<body>


  <meta charset="utf-8">
  <title>Opus Hardware – SP14 Designer (beta)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
<!-- 
SP14 Designer Notes:
 - PS1 tables: Uses SP14 internal spacing and overhang values. Balustrade tables cover glass thicknesses 12, 13.52, 15 and 17.52 mm with height bands up to 1300 mm and wind zones L, M, H, VH, EH. Pool tables cover 12 mm and 15 mm thicknesses with height ranges 1200–1300 mm. Edge distances are 250 mm for balustrade and 500 mm (with reduced edge distances 375 mm/300 mm for higher wind zones) for pool as per SP14 PS1.
 - Spigot calculation: For each panel, spigots = max(2, ceil((panelWidth − 2 × edge) / internalSpacing) + 1). Spigots are limited by spigot mode (auto: as needed; 2 or 3 posts per panel). Panel widths are found using the existing symmetrical/mixed solver with maximum width = edge × 2 + (spigots − 1) × internalSpacing and gap constraints (10–60 mm for pool, 10–26 mm for balustrade).
 - Gate math: Gate clear opening subtracts 890 mm from the selected run (includes hinge and latch allowances). Two gate posts are added per gate. Gate hardware codes ASC180 (hinges) and PL180GG (latch) are included. Hinge‑leaf and minimum hinge‑panel width rules follow SD50 logic.
 - Deviations: SD50‑specific disc head picker, packers and disc powdercoat logic have been removed. Discs are replaced by posts/spigots and fixings kits for SP14. 3D view renders SP14 posts and spigots (cylinders) instead of discs.
-->

  <!-- j        <div>
          <label>Fixing type</label>
          <select id="fixingType">
            <option value="">– select –</option>
            <option value="Concrete">Concrete</option>
            <option value="Steel">Steel</option>
            <option value="Timber (Coach Screw)">Timber (Coach Screw)</option>
            <option value="Timber (Bolt Through)">Timber (Bolt Through)</option>
          </select>
        </div> PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- SP14 PS1 spacing & edge distances loaded from CSV -->
  <script>
  // SP14 PS1 data: each entry defines the internal spacing and edge distance for a particular system, thickness,
  // height band and wind zone. This table is generated from the uploaded CSV. Do not modify manually.
  const SP14_PS1 = [
    // Balustrade 12mm thickness
    {"system":"balustrade","thk":12.0,"hmin":1000,"hmax":1150,"zone":"L","internal":800,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1150,"hmax":1200,"zone":"L","internal":720,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1000,"hmax":1150,"zone":"M","internal":800,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1150,"hmax":1200,"zone":"M","internal":720,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1000,"hmax":1100,"zone":"H","internal":800,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1100,"hmax":1200,"zone":"H","internal":720,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1000,"hmax":1050,"zone":"VH","internal":800,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1050,"hmax":1100,"zone":"VH","internal":720,"edge":250},
    {"system":"balustrade","thk":12.0,"hmin":1000,"hmax":1050,"zone":"EH","internal":720,"edge":250},
    // Balustrade 13.52mm thickness (same as 12mm)
    {"system":"balustrade","thk":13.52,"hmin":1000,"hmax":1150,"zone":"L","internal":800,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1150,"hmax":1200,"zone":"L","internal":720,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1000,"hmax":1150,"zone":"M","internal":800,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1150,"hmax":1200,"zone":"M","internal":720,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1000,"hmax":1100,"zone":"H","internal":800,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1100,"hmax":1200,"zone":"H","internal":720,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1000,"hmax":1050,"zone":"VH","internal":800,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1050,"hmax":1100,"zone":"VH","internal":720,"edge":250},
    {"system":"balustrade","thk":13.52,"hmin":1000,"hmax":1050,"zone":"EH","internal":720,"edge":250},
    // Balustrade 15mm thickness
    {"system":"balustrade","thk":15.0,"hmin":1000,"hmax":1200,"zone":"L","internal":800,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1200,"hmax":1300,"zone":"L","internal":720,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1000,"hmax":1200,"zone":"M","internal":800,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1200,"hmax":1300,"zone":"M","internal":720,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1000,"hmax":1200,"zone":"H","internal":800,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1200,"hmax":1300,"zone":"H","internal":720,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1000,"hmax":1150,"zone":"VH","internal":800,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1150,"hmax":1250,"zone":"VH","internal":720,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1000,"hmax":1100,"zone":"EH","internal":800,"edge":250},
    {"system":"balustrade","thk":15.0,"hmin":1100,"hmax":1200,"zone":"EH","internal":720,"edge":250},
    // Balustrade 17.52mm thickness (same as 15mm)
    {"system":"balustrade","thk":17.52,"hmin":1000,"hmax":1200,"zone":"L","internal":800,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1200,"hmax":1300,"zone":"L","internal":720,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1000,"hmax":1200,"zone":"M","internal":800,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1200,"hmax":1300,"zone":"M","internal":720,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1000,"hmax":1200,"zone":"H","internal":800,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1200,"hmax":1300,"zone":"H","internal":720,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1000,"hmax":1150,"zone":"VH","internal":800,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1150,"hmax":1250,"zone":"VH","internal":720,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1000,"hmax":1100,"zone":"EH","internal":800,"edge":250},
    {"system":"balustrade","thk":17.52,"hmin":1100,"hmax":1200,"zone":"EH","internal":720,"edge":250},
    // Pool 12mm thickness
    {"system":"pool","thk":12.0,"hmin":1200,"hmax":1200,"zone":"L","internal":1200,"edge":500},
    {"system":"pool","thk":12.0,"hmin":1200,"hmax":1200,"zone":"M","internal":1200,"edge":500},
    {"system":"pool","thk":12.0,"hmin":1200,"hmax":1200,"zone":"H","internal":1000,"edge":500},
    {"system":"pool","thk":12.0,"hmin":1200,"hmax":1200,"zone":"VH","internal":750,"edge":375},
    // No EH row for 12mm pool (not suitable)
    // Pool 15mm thickness
    {"system":"pool","thk":15.0,"hmin":1200,"hmax":1300,"zone":"L","internal":1000,"edge":500},
    {"system":"pool","thk":15.0,"hmin":1200,"hmax":1300,"zone":"M","internal":1000,"edge":500},
    {"system":"pool","thk":15.0,"hmin":1200,"hmax":1300,"zone":"H","internal":750,"edge":375},
    {"system":"pool","thk":15.0,"hmin":1200,"hmax":1300,"zone":"VH","internal":600,"edge":300},
    {"system":"pool","thk":15.0,"hmin":1200,"hmax":1200,"zone":"EH","internal":600,"edge":300}
  ];
  // Minimum allowed edge distance (mm). PS1 defines maximum only; we enforce a conservative minimum of 100 mm.
  const EDGE_MIN = 100;
  /**
   * Look up the SP14 PS1 row matching the given system ('pool' or 'balustrade'), glass thickness (string or number),
   * glass height (string or number) and wind zone code (L,M,H,VH,EH). Returns the closest height band if the exact
   * band does not exist. If nothing matches, returns null.
   */
function ps14Lookup(system, thk, ht, zone) {
    thk = parseFloat(thk);
    ht = parseFloat(ht);
    zone = String(zone || '').toUpperCase();
    // Filter rows that match system, thickness and zone and where height lies within band
    let rows = SP14_PS1.filter(r => r.system === system && Math.abs(r.thk - thk) < 0.01 && r.zone === zone && ht >= r.hmin && ht <= r.hmax);
    if (rows.length > 0) return rows[0];
    // If no exact band match, select the closest band (by mid-point) for the same system/thk/zone
    rows = SP14_PS1.filter(r => r.system === system && Math.abs(r.thk - thk) < 0.01 && r.zone === zone);
    if (rows.length === 0) return null;
    rows.sort((a, b) => Math.abs(((a.hmin + a.hmax) / 2) - ht) - Math.abs(((b.hmin + b.hmax) / 2) - ht));
    return rows[0];
  }
  </script>

  <style>
    :root {
      --bg: #fcfcf8;
      --card: #fff;
      --text: #222;
      --primary: #111;
      --accent: #0077c8;
      --border: #eaeaea;
      --radius: 12px;
    }
    * { box-sizing:border-box }
    html,body { margin:0;padding:0;font-family:system-ui,Arial,sans-serif;background:var(--bg);color:var(--text) }
    h1 { 
      font: 700 2.2rem/1.2 'Inter', system-ui, Arial, sans-serif;
      text-align: center;
      margin: 0;
      color: #2c3e50;
      letter-spacing: 0.02em;
      background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .title-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8fafe 100%);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      padding: 2.5rem;
      margin: 2rem 0;
      text-align: center;
      position: relative;
      border: 1px solid #e3f2fd;
      overflow: hidden;
    }
    
    .title-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #0077c8, #3498db, #0077c8);
      border-radius: 20px 20px 0 0;
    }
    
    .title-card .beta-badge {
      display: inline-block;
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
      color: white;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 1rem;
      box-shadow: 0 2px 8px rgba(255,107,107,0.3);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .title-card .subtitle {
      color: #64748b;
      font-size: 1.1rem;
      margin-top: 0.5rem;
      font-weight: 400;
      opacity: 0.8;
    }
    h2 {
      font: 600 1.5rem/1.2 'Inter', system-ui, Arial, sans-serif;
      text-align: center;
      margin: 0 0 1.5rem 0;
      color: #2c3e50;
      letter-spacing: 0.02em;
    }
    .container { max-width:960px;margin:auto;padding:0 1rem 4rem }
    .card { 
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
      padding: 2.5rem;
      margin-top: 2rem;
      position: relative;
      border: 1px solid #e9ecef;
    }
    label { font-weight:600;margin-top:.8rem;display:block }
    input[type="number"], select { 
      width: 100%;
      padding: .5rem;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: #fafaf7;
      font-size: 1rem;
      margin-bottom: 0.8em;
    }
    /* force checkboxes to appear in Shopify */
    input[type="checkbox"] {
      -webkit-appearance:checkbox;
      appearance:checkbox;
      display:inline-block;
      width:auto;
      margin-right:.5rem;
      vertical-align:middle;
    }
    /* default buttons are full‑width… */
    button { 
      display: block;
      width: 100%;
      margin-top: 2rem;
      padding: 1rem 2rem;
      font: 600 1.1rem 'Inter', system-ui, Arial, sans-serif;
      color: #fff;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      letter-spacing: 0.03em;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #0077c8 0%, #005fa3 100%);
      box-shadow: 0 4px 12px rgba(0,119,200,0.3);
    }
    button:not([disabled]):hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,119,200,0.4);
      background: linear-gradient(135deg, #005fa3 0%, #004a82 100%);
    }
    button:not([disabled]) { 
      background: linear-gradient(135deg, #0077c8 0%, #005fa3 100%);
    }
    button[disabled] { 
      background: linear-gradient(135deg, #d0d0d0 0%, #bbb 100%);
      color: #666;
      cursor: not-allowed;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transform: none;
    }
    /* back button override */
    #backBtn {
      width:auto!important;
      display:inline-block!important;
      background:#6c757d;
      position:absolute; top:1rem; right:1rem; padding:.35rem .9rem; font-size:.8rem;
    }
    #backBtn:hover { background:#565e64 }
    #calcBtn { background:#000 }    #calcBtn:hover { background:#333 }
    #emailBtn { background:#28a745 } #emailBtn:hover { background:#218838 }
    #viewBtn  { background:#0d6efd } #viewBtn:hover  { background:#0b5ed7 }
    #pdfBtn   { background:#0077c8 } #pdfBtn:hover   { background:#0062a8 }

    /* Glass Order PDF button styling matches other primary action buttons */
/* Style the glass order button similarly to the other PDF/3D buttons.  It uses the same accent colours and flex sizing so it fills the available space. */
#orderPdfBtn {
  background: #0077c8;
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  padding: 10px 20px;
  cursor: pointer;
  flex: 1;
}
#orderPdfBtn:hover {
  background: #0062a8;
}
    #view3dBtn { background:#28a745 } #view3dBtn:hover { background:#1e7e34 }
    .flexBtns { display:flex;gap:.8rem;margin-top:1rem }
    .results-table,.order-table { width:100%;border-collapse:collapse;margin-top:1rem }
    .results-table th,.results-table td,
    .order-table th,.order-table td { border:1px solid #ddd;padding:.5rem;text-align:center }
    .results-table th,.order-table th { background:#f0f0f0 }
    @media(min-width:640px){ .grid { display:grid;grid-template-columns:repeat(2,1fr);gap:1rem } }
    /* shape‐picker tiles */
    #shapeGrid { display:grid;grid-template-columns:repeat(4,1fr);gap:1.5rem;margin-top:2rem;max-width:1000px;margin-left:auto;margin-right:auto }
    .shape-card { 
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e9ecef;
      border-radius: 16px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      position: relative;
      overflow: hidden;
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .shape-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #0077c8, #28a745, #0077c8);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .shape-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      border-color: #0077c8;
    }
    .shape-card:hover::before {
      opacity: 1;
    }
    .shape-card.selected { 
      border-color: #0077c8;
      box-shadow: 0 8px 25px rgba(0,119,200,0.2);
      background: linear-gradient(135deg, #f8fbff 0%, #e8f4ff 100%);
    }
    .shape-card.selected::before {
      opacity: 1;
    }
    .shape-card img { 
      width: 100%;
      height: 150px;
      object-fit: contain;
      border-radius: 8px;
      background: linear-gradient(135deg, #f7f9fc 0%, #eef2f7 100%);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .shape-card p { 
      text-align: center;
      margin: 0.5rem 0 0;
      font-weight: 600;
      font-size: 1.1rem;
      color: #2c3e50;
      letter-spacing: 0.02em;
    }
    /* make only the little panel‐view scroll, not the whole page */
    .view { overflow-x:auto }
    /* --- Add below your existing :root or at the end of <style> --- */
:root {
  --bg: #fcfcf8;
  --card: #fff;
  --text: #222;
  --primary: #111;
  --accent: #0077c8;
  --border: #eaeaea;
  --radius: 12px;
}

body, html {
  background: var(--bg);
  color: var(--text);
}

.card {
  background: var(--card);
  border-radius: var(--radius);
  box-shadow: 0 2px 8px rgba(0,0,0,0.04);
  border: 1px solid var(--border);
}

h1, h2 {
  font-family: 'Inter', system-ui, Arial, sans-serif;
  font-weight: 600;
  color: var(--primary);
  letter-spacing: 0.01em;
}

label {
  font-weight: 500;
  color: var(--primary);
  margin-bottom: 0.3em;
}

input[type="number"], select {
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: #fafaf7;
  font-size: 1rem;
  padding: 0.6em;
  margin-bottom: 0.8em;
}

button {
  background: var(--primary);
  color: #fff;
  border-radius: var(--radius);
  font-weight: 600;
  letter-spacing: 0.03em;
  transition: background 0.2s;
}

button:not([disabled]):hover {
  background: var(--accent);
}

.results-table th, .order-table th {
  background: #f7f7f7;
  color: var(--primary);
  font-weight: 500;
}

.results-table td, .order-table td {
  background: #fff;
  color: var(--text);
}

.shape-card {
  border: 1px solid var(--border);
  box-shadow: none;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.shape-card.selected {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent);
}

.shape-card img {
  border-radius: var(--radius);
  background: #f7f7f7;
}

.flexBtns button {
  background: var(--accent);
  color: #fff;
}

.flexBtns button:hover {
  background: #005fa3;
}

/* Hide stray logos outside main container */
body > img[src*="opus"],
body > img[src*="logo"],
.site-header img,
.header-logo,
.logo:not(.container .logo),
body > div:first-child img {
  display: none !important;
}

/* More aggressive logo hiding */
body > *:not(.container) img[src*="logo"],
body > *:not(.container) img[src*="opus"] {
  display: none !important;
}
    .disc-head-card {
      background:#fff;
      border:2px solid #ccc;
      border-radius:12px;
      padding:8px 10px 4px 10px;
      cursor:pointer;
      transition:.2s;
      box-shadow:0 2px 6px rgba(0,0,0,.07);
      outline:none;
      width:110px;
      text-align:center;
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    .disc-head-card.selected {
      border-color:#0077c8;
      box-shadow:0 0 0 3px #0077c84a;
    }
    .disc-head-card:focus {
      border-color:#0077c8;
      box-shadow:0 0 0 3px #0077c84a;
    }
    #powdercoatColor {
      display: none;
      margin-top: 0.5rem;
    }
    
    /* Gate Control Button Styles - Black Design */
    .liveGateLeft, .liveGateRight, .liveGateFlip {
      /* Unified gate control button styling (compact) */
      background: #000 !important;
      border: 1px solid #333 !important;
      border-radius: 4px !important;
      color: #ffffff !important;
      cursor: pointer !important;
      font-weight: 500 !important;
      font-size: 0.85rem !important;
      padding: 0.4rem 0.5rem !important;
      transition: background 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: flex-start !important;
      gap: 0.6rem !important;
      min-height: 36px !important;
      width: auto !important;
      min-width: 0 !important;
      white-space: nowrap !important;
    }
    
    .liveGateLeft:hover, .liveGateRight:hover, .liveGateFlip:hover {
      background: #34495e !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25) !important;
      border-color: #4a6741 !important;
    }
    
    .liveGateLeft:active, .liveGateRight:active, .liveGateFlip:active {
      transform: translateY(0) !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
      background: #1a252f !important;
    }
    
    .liveGateLeft:disabled, .liveGateRight:disabled {
      opacity: 0.4 !important;
      cursor: not-allowed !important;
      transform: none !important;
      background: #7f8c8d !important;
      color: #bdc3c7 !important;
      border-color: #95a5a6 !important;
    }
    
    .liveGateLeft:disabled:hover, .liveGateRight:disabled:hover {
      background: #7f8c8d !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
      transform: none !important;
      border-color: #95a5a6 !important;
    }

    /* Icon and label styling for gate control buttons */
    .liveGateLeft .icon, .liveGateRight .icon, .liveGateFlip .icon {
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      width: 20px !important;
      height: 20px !important;
      line-height: 20px !important;
      border-radius: 50% !important;
      background: #ffffff !important;
      color: #000000 !important;
      font-size: 0.75rem !important;
      font-weight: 600 !important;
      flex-shrink: 0 !important;
    }
    .liveGateLeft .label, .liveGateRight .label, .liveGateFlip .label {
      color: #ffffff !important;
      font-size: 0.75rem !important;
      font-weight: 500 !important;
      white-space: nowrap !important;
    }
    
    /* Arrow and icon styling */
    .liveGateLeft span, .liveGateRight span, .liveGateFlip span {
      display: inline-block;
      font-size: 0.85rem;
    }
  </style>



<div class="container">
  
  <div class="title-card">
    <h1 id="mainTitle" style="display:flex;align-items:center;justify-content:center;gap:1.5rem;">
      <!-- Updated to SP14: use SP14 product image and update title -->
      <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/SP14-SS.jpg?v=1745468490" alt="SP14 System" style="width:80px;height:80px;object-fit:contain;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.15);display:block!important;" onload="console.log('SP14 image loaded successfully')" onerror="console.log('Failed to load SP14 image, trying fallback'); this.src='https://via.placeholder.com/80x80/0077c8/ffffff?text=SP14';">
      Opus Hardware – SP14 Designer
      <span class="beta-badge">Beta</span>
    </h1>
    <p class="subtitle">Professional fence design and calculation tool</p>
  </div>
  <!-- SHAPE PICKER -->
    <div id="shapePicker" class="card">
      <h2 style="text-align:center;font-size:1.8rem;margin-bottom:1.5rem;color:#2c3e50;">
        Select Fence Shape
      </h2>
      <div id="shapeGrid">
        <div class="shape-card" data-id="INLINE">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/inline_png.png?v=1752528420" alt="Inline" style="display:block!important;" onload="console.log('Inline image loaded successfully')" onerror="console.log('Failed to load Inline image, using fallback'); this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'200\' viewBox=\'0 0 200 200\'%3E%3Crect width=\'200\' height=\'200\' fill=\'%23f0f0f0\'/%3E%3Ctext x=\'100\' y=\'100\' text-anchor=\'middle\' dy=\'0.3em\' font-family=\'Arial\' font-size=\'16\' fill=\'%23666\'%3EInline%3C/text%3E%3C/svg%3E';">
          <p>Inline</p>
        </div>
        <div class="shape-card" data-id="L">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/lshaped_png.png?v=1752528420" alt="Corner (L)" style="display:block!important;" onload="console.log('L-shape image loaded successfully')" onerror="console.log('Failed to load L-shape image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=L+Shape';">
          <p>Corner (L)</p>
        </div>
        <div class="shape-card" data-id="U">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/ushape_png.png?v=1752528420" alt="U Shape" style="display:block!important;" onload="console.log('U-shape image loaded successfully')" onerror="console.log('Failed to load U-shape image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=U+Shape';">
          <p>U Shape</p>
        </div>
        <div class="shape-card" data-id="BOX">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/enclosed_png.png?v=1752528421" alt="Enclosed" style="display:block!important;" onload="console.log('Enclosed image loaded successfully')" onerror="console.log('Failed to load Enclosed image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=Enclosed';">
          <p>Enclosed</p>
        </div>
      </div>
      <div id="customTile" style="display:flex;justify-content:center;align-items:center;margin-top:2rem;width:100%;">
        <div class="shape-card" data-id="CUSTOM" style="width:240px;flex-shrink:0;">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/custom.png?v=1752805887" alt="Custom" style="display:block!important;" onload="console.log('Custom image loaded successfully')" onerror="console.log('Failed to load Custom image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=Custom';">
          <p>Custom</p>
        </div>
      </div>
      <button id="shapeNext" disabled>NEXT</button>
    </div>

    <!-- CALCULATOR -->
    <div id="calcCard" class="card" style="display:none">
      <button id="backBtn">← Back</button>

      <div id="shapeDiagram" style="text-align:center;margin:1rem 0"></div>

      <!-- SVG Drawing Pad (shows only for Custom shape) -->
      <div id="svgDrawSection" style="display:none; margin:2rem -4rem; padding:1.5rem; border:2px dashed #0077c8; border-radius:12px; background:linear-gradient(135deg, #f8fbff 0%, #e8f4ff 100%); max-width:none; width:calc(100% + 8rem);">
        <h3 style="margin:0 0 1rem 0; text-align:center; color:#0077c8; font-size:1.4rem;">✏️ Draw Your Custom Shape</h3>
        <p style="text-align:center; color:#666; margin-bottom:1.5rem; font-size:0.95rem;">Click points to create your fence layout. Each line represents a side of your fence.</p>
        <div style="display:flex; justify-content:center; margin-bottom:1rem;">
          <svg id="svgGridPad" width="95%" height="500" style="border:2px solid #0077c8; background:#fff; border-radius:8px; cursor:crosshair; max-width:1400px;"></svg>
        </div>
        <div id="svgSideLengths" style="margin:1rem 0; font-weight:600; text-align:center; color:#0077c8; min-height:2rem;"></div>
        <div style="display:flex; justify-content:center; flex-wrap:wrap; gap:0.3rem; margin-top:0.8rem;">
          <button id="svgUndoBtn" type="button" style="background:#17a2b8; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center;" disabled>↶</button>
          <button id="svgRedoBtn" type="button" style="background:#17a2b8; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center;" disabled>↷</button>
          <button id="svgDoneBtn" type="button" style="background:#28a745; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.75rem; display:flex; align-items:center; justify-content:center;">✓</button>
          <button id="svgClearBtn" type="button" style="background:#dc3545; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.75rem; display:flex; align-items:center; justify-content:center;">✕</button>
          <button id="svgEditBtn" type="button" style="background:#ffc107; color:#333; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.75rem; display:flex; align-items:center; justify-content:center; display:none;">✎</button>
          <button id="svgSubmitLayoutBtn" type="button" style="background:#0077c8; color:white; padding:0.4rem 1.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center;">Apply Side Lengths</button>
        </div>
      </div>

      <div id="sideInputs"></div>

      <div class="grid">
        <div>
          <label>Fence type</label>
          <select id="fenceType">
            <option value="balustrade">Balustrade (14–20 mm)</option>
            <option value="pool">Pool Fence (15–99 mm)</option>
          </select>
        </div>

        <div>
          <label>Fixing type</label>
          <select id="fixingType">
            <option value="">– select –</option>
            <option value="Concrete (Single Fix)">Concrete (Single Fix)</option>
            <option value="Concrete (Double Fix)">Concrete (Double Fix)</option>
            <option value="Steel Fix">Steel Fix</option>
            <option value="Timber Fix (Coach Screw)">Timber Fix (Coach Screw)</option>
            <option value="Timber Fix (Through Bolts)">Timber Fix (Through Bolts)</option>
          </select>
        </div>

        <div>
          <label>Wind zone</label>
          <select id="windZone">
            <option value="L">L</option>
<option value="M">M</option>
            <option value="H">H</option>
<option value="VH">VH</option>
<option value="EH">EH</option>
          </select>
        </div>

        <div>
          <label>Glass height (mm)</label>
          <select id="glassHt">
            <!-- Removed 950 mm option per latest requirements -->
<option>1000</option>
<option>1050</option>
            <option>1100</option>
<option>1150</option>
<option>1200</option>
<option>1250</option>
          </select>
        </div>

        <div>
<label>Glass thickness</label><select id="glassThk"></select>
</div>
        <div>
<label>Handrail</label><select id="handrailType"></select>
</div>
        <div>
          <label>Hardware finish</label>
          <select id="finishType">
            <option value="SS">SSS</option>
<option value="PS">PSS</option>
<option value="BK">BK</option>
            <option value="PC">Powdercoated (specify colour)</option>
          </select>
          <input type="text" id="powdercoatColor" placeholder="Enter colour (e.g. Matt Black, White, etc.)" style="display:none;margin-top:0.5rem;">
        </div>
        <input id="cornerCount" type="hidden">

        <!-- mixed‐panel checkbox -->
        <div style="grid-column:1/2">
          <label>
            <input type="checkbox" id="allowMixed">
            Allow mixed panel sizes (±200 mm)
          </label>
        </div>
        <div>
          <!-- SP14 spigot mode selector -->
          <label>Spigots per panel:</label>
          <div style="display:flex;gap:0.5rem;align-items:center;">
            <label><input type="radio" name="spigotMode" id="spigotModeAuto" value="auto" checked>Auto</label>
            <label><input type="radio" name="spigotMode" id="spigotMode2" value="2">2&nbsp;posts&nbsp;per&nbsp;panel</label>
            <label><input type="radio" name="spigotMode" id="spigotMode3" value="3">3&nbsp;posts&nbsp;per&nbsp;panel</label>
          </div>
        </div>
      </div>

      <!-- DISC HEAD TYPE PICKER -->
      <!-- SP14: Removed SD50 disc head picker and extra packers -->
      <!-- (disc head selector and extra packer UI elements removed for SP14 designer) -->

      <button id="calcBtn">Calculate compliant layout</button>
      <div id="output"></div>

      <div id="orderList" style="display:none">
        <table class="order-table">
          <thead>
            <tr><th colspan="3">Order List</th></tr>
            <tr>
<th>Description</th>
<th>Code</th>
<th>Qty</th>
</tr>
          </thead>
          <tbody></tbody>
        </table>
        <button id="emailBtn">Email Order List</button>
        <div class="flexBtns">
          <button id="pdfBtn">Download Plan (PDF)</button>
          <button id="orderPdfBtn">Download Glass Order (PDF)</button>
          <button id="view3dBtn">View 3D Plan</button>
        </div>
      </div>
    </div>

    <!-- Drawing UI removed - now integrated into calculator form -->

    <div id="visual"></div>
  </div>

  <script>
  // ─── Helpers & State ───────────────────────────────────────
  const $ = id=>document.getElementById(id),
        PX = .2,
        MAR= 120,  // Increased margin for arrow space
        rnd= x=>+x.toFixed(1),
        letters='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  let layouts=[], sideLens=[];

  // ─── Shape picker ─────────────────────────────────────────
const shapes=[
  {id:'INLINE',label:'Inline',sides:1,corners:0,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/inline_png.png?v=1752528420'},
  {id:'L',     label:'Corner (L)',sides:2,corners:1,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/lshaped_png.png?v=1752528420'},
  {id:'U',     label:'U Shape',   sides:3,corners:2,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/ushape_png.png?v=1752528420'},
  {id:'BOX',   label:'Enclosed',  sides:4,corners:4,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/enclosed_png.png?v=1752528421'}
];
// Images now loaded directly in HTML - commenting out dynamic generation
/*
shapes.forEach(s=>
  $('shapeGrid').insertAdjacentHTML('beforeend',`
    <div class="shape-card" data-id="${s.id}">
      <img src="${s.img}" alt="${s.label}" onerror="console.log('Failed to load image: ${s.img}')">
      <p>${s.label}</p>
    </div>`)
);

// Add custom tile
$('customTile').innerHTML = `
  <div class="shape-card" data-id="CUSTOM" style="max-width:350px;">
    <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/custom.png?v=1752805887" alt="Custom" onerror="console.log('Failed to load custom image')">
    <p>Custom</p>
  </div>
`;
*/

  let curShape=null;
  let selectedDiscHead = null;

// Handle clicks on both main grid and custom tile
function handleShapeClick(e) {
  console.log('Shape click event triggered', e.target);
  const c=e.target.closest('.shape-card');
  console.log('Found shape card:', c);
  if(!c) return;
  
  console.log('Shape selected:', c.dataset.id);
  document.querySelectorAll('.shape-card').forEach(n=>n.classList.remove('selected'));
  c.classList.add('selected');
  
  if(c.dataset.id === 'CUSTOM') {
    curShape = {id:'CUSTOM',label:'Custom',sides:1,corners:0};
    $('shapeNext').disabled=false;
    
    // Show SVG drawing section immediately for Custom shape
    const svgDrawSection = document.getElementById('svgDrawSection');
    if(svgDrawSection) {
      svgDrawSection.style.display = 'block';
    }
    
    // Initialize drawing variables
    if(typeof points !== 'undefined') {
      points = [];
      ghost = null;
      currentDrawingPoint = null;
      currentDrawingPointIndex = null;
      isDrawingMode = true;
      if(typeof drawFreehandPad === 'function') drawFreehandPad();
      if(typeof updateFreehandSideLengths === 'function') updateFreehandSideLengths();
      if(typeof updateUI === 'function') updateUI();
    }
    return;
  }
  
  // Hide SVG drawing section for non-custom shapes
  const svgDrawSection = document.getElementById('svgDrawSection');
  if(svgDrawSection) svgDrawSection.style.display = 'none';
  
  curShape=shapes.find(o=>o.id===c.dataset.id);
  console.log('Current shape set to:', curShape);
  $('shapeNext').disabled=false;
  
  // Redraw the shape diagram when a shape is selected
  if(typeof drawMini === 'function') {
    drawMini();
  }
}

// Robust event handler attachment
const shapeGrid = $('shapeGrid');
const customTile = $('customTile');

if (shapeGrid) {
  console.log('Attaching event handler to shapeGrid');
  shapeGrid.onclick = handleShapeClick;
} else {
  console.error('shapeGrid element not found!');
}

if (customTile) {
  console.log('Attaching event handler to customTile');
  customTile.onclick = handleShapeClick;
} else {
  console.error('customTile element not found!');
}

// ─── Hardware finish handlers ────────────────────────────
$('finishType').onchange = function() {
  const powdercoatInput = $('powdercoatColor');
  if (this.value === 'PC') {
    powdercoatInput.style.display = 'block';
  } else {
    powdercoatInput.style.display = 'none';
  }
};

// ─── Disc head selection handlers ────────────────────────
document.querySelectorAll('.disc-head-card').forEach(card => {
  card.onclick = function() {
    // Remove selected class from all cards
    document.querySelectorAll('.disc-head-card').forEach(c => c.classList.remove('selected'));
    // Add selected class to clicked card
    this.classList.add('selected');
    // Store selection
    selectedDiscHead = this.getAttribute('data-head');
  };
  
  card.onkeydown = function(e) {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      this.click();
    }
  };
});

// Select first disc head by default
if (document.querySelector('.disc-head-card')) {
  document.querySelector('.disc-head-card').click();
}

  // ─── Navigation ───────────────────────────────────────────
  const shapeNextBtn = document.getElementById('shapeNext');
  
  if(shapeNextBtn) {
    shapeNextBtn.onclick = function() {
      // Use direct DOM manipulation
      document.getElementById('shapePicker').style.display = 'none';
      const calcCard = document.getElementById('calcCard');
      if(calcCard) {
        calcCard.style.display = 'block';
        calcCard.style.visibility = 'visible';
      }
      
      // Handle Custom shape differently - show SVG pad, don't build standard inputs
      if(curShape && curShape.id === 'CUSTOM') {
        // Hide shape diagram for custom shapes (not needed)
        const shapeDiagram = document.getElementById('shapeDiagram');
        if(shapeDiagram) {
          shapeDiagram.style.display = 'none';
        }
        
        // Clear any existing side inputs 
        const sideInputsDiv = document.getElementById('sideInputs');
        if(sideInputsDiv) sideInputsDiv.innerHTML = '';
        
        // Show SVG drawing section
        const svgDrawSection = document.getElementById('svgDrawSection');
        if(svgDrawSection) {
          svgDrawSection.style.display = 'block';
        }
        
        // Initialize drawing variables
        if(typeof points !== 'undefined') {
          points = [];
          ghost = null;
          currentDrawingPoint = null;
          currentDrawingPointIndex = null;
          isDrawingMode = true;
          if(typeof drawFreehandPad === 'function') drawFreehandPad();
          if(typeof updateFreehandSideLengths === 'function') updateFreehandSideLengths();
          if(typeof updateUI === 'function') updateUI();
        }
        
        // Populate dropdowns
        if(typeof refreshSelectors === 'function') {
          refreshSelectors();
        }
      } else {
        // Standard shapes - hide SVG pad and build normal inputs
        const svgDrawSection = document.getElementById('svgDrawSection');
        if(svgDrawSection) svgDrawSection.style.display = 'none';
        if(typeof buildSideInputs === 'function') buildSideInputs(); 
        if(typeof drawMini === 'function') drawMini(); 
        if(typeof refreshSelectors === 'function') refreshSelectors();
      }
      
      const cornerCount = document.getElementById('cornerCount');
      if(cornerCount) cornerCount.value = curShape ? (curShape.corners || 0) : 0;
    };
  }
  $('backBtn').onclick=()=>{
    // Hide calculation interface and show shape picker
    $('calcCard').style.display='none';
    $('shapePicker').style.display='';
    $('opusLogo').style.display='none';
    
    // Reset title back to generic
    $('mainTitle').innerHTML = `
      Opus Hardware – Glass Designer
      <span class="beta-badge">Beta</span>
    `;
    
    // Reset shape selection
    document.querySelectorAll('.shape-card').forEach(c=>c.classList.remove('selected'));
    $('shapeNext').disabled=true;
    
    // Clear all visual displays and prevent redrawing
    $('visual').innerHTML=''; 
    $('output').innerHTML=''; 
    $('orderList').style.display='none';
    $('sideInputs').innerHTML='';
    
    // Force clear visual area and prevent any lingering content
    const visualElement = $('visual');
    if(visualElement) {
      visualElement.innerHTML = '';
      visualElement.style.display = '';
      // Remove any child elements that might have been added
      while(visualElement.firstChild) {
        visualElement.removeChild(visualElement.firstChild);
      }
    }
    
    // Reset all main form inputs to default values
    $('fenceType').value = 'balustrade';
    $('fixingType').value = 'standoff';
    $('windZone').value = 'N1';
    $('glassHt').value = '1000';
    $('glassThk').value = '12';
    $('handrailType').value = 'none';
    $('finishType').value = 'mill';
    $('powdercoatColor').value = '';
    $('powdercoatColor').style.display = 'none';
    $('cornerCount').value = '';
    $('extraPackers').value = '';
    
    // Reset checkboxes to default state
    $('allowMixed').checked = true;
    $('limit4Discs').checked = false;
    
    // Clear all dynamic spanLen inputs (side lengths)
    document.querySelectorAll('.spanLen').forEach(input => {
      input.value = '';
    });
    
    // Reset any gate-related controls that might exist
    document.querySelectorAll('input[type="checkbox"][class*="gate"]').forEach(checkbox => {
      checkbox.checked = false;
    });
    document.querySelectorAll('input[type="range"][class*="gate"]').forEach(slider => {
      slider.value = slider.min || 0;
    });
    
    // Clear any dynamically generated content areas
    $('shapeDiagram').innerHTML = '';
    
    // Hide SVG drawing section if visible
    const svgSection = $('svgDrawSection');
    if(svgSection) svgSection.style.display = 'none';
    
    // Clear SVG pad if it exists
    const svgPad = $('svgGridPad');
    if(svgPad) svgPad.innerHTML = '';
    
    // Clear side lengths display
    const sideLengths = $('svgSideLengths');
    if(sideLengths) sideLengths.innerHTML = '';
    
    // Reset disc head picker selections
    document.querySelectorAll('#discHeadPicker .disc-option').forEach(option => {
      option.classList.remove('selected');
    });
    
    // Reset global variables and clear all data
    curShape = null;
    if(typeof layouts !== 'undefined') layouts = [];
    if(typeof sideLens !== 'undefined') sideLens = [];
    if(typeof layout !== 'undefined') layout = null;
    if(typeof spans !== 'undefined') spans = [];
    if(typeof points !== 'undefined') points = [];
    if(typeof finishedShapes !== 'undefined') finishedShapes = [];
    
    // Clear any cached layout data
    if(typeof currentLayout !== 'undefined') currentLayout = null;
    if(typeof calculatedLayouts !== 'undefined') calculatedLayouts = [];
    
    // Refresh selectors to reset dependent options
    if(typeof refreshSelectors === 'function') refreshSelectors();
    
    // Ensure visual area stays clear by preventing any automatic redraws
    setTimeout(() => {
      if($('visual')) $('visual').innerHTML = '';
    }, 100);
  };

  // ─── Side inputs & mini ───────────────────────────────────
  function buildSideInputs(){
      document.addEventListener('focusin', () => drawMini());
document.addEventListener('focusout', () => drawMini());
    $('sideInputs').innerHTML='<div class="grid">'+
      [...Array(curShape.sides).keys()].map(i=>`
        <div>
          <label>Side ${letters[i]} length (mm)</label>
          <input type="number" class="spanLen" data-i="${i}" min="500">
          <div style="margin-top:0.5rem;">
            <label style="display:flex;align-items:center;gap:0.5rem;font-size:0.9rem;color:#666;">
              <input type="checkbox" class="gateRequired" data-i="${i}" style="margin:0;">
              Gate required? (890mm + clearances)
            </label>
          </div>
        </div>`).join('')+
    '</div>';
    document.querySelectorAll('.spanLen').forEach(inp=>{
      inp.onfocus=()=>highlight(+inp.dataset.i);
      inp.onblur =()=>highlight(null);
    });
    
    // Gate checkbox event handlers
    document.querySelectorAll('.gateRequired').forEach(checkbox => {
      checkbox.onchange = () => {
        const sideIndex = checkbox.dataset.i;
        const positionControls = document.querySelector(`.gatePositionControls[data-i="${sideIndex}"]`);
        
        if (checkbox.checked) {
          positionControls.style.display = 'block';
          // Initialize gate position if not set
          if (!checkbox.dataset.gatePosition) {
            checkbox.dataset.gatePosition = 'middle';
          }
        } else {
          positionControls.style.display = 'none';
        }
        
        console.log(`Gate ${checkbox.checked ? 'enabled' : 'disabled'} for side ${letters[checkbox.dataset.i]}`);
        drawMini(); // Refresh the mini preview
      };
    });

    // Gate position button handlers
    document.querySelectorAll('.gateLeft, .gateRight').forEach(button => {
      button.onclick = () => {
        const sideIndex = button.dataset.i;
        const checkbox = document.querySelector(`.gateRequired[data-i="${sideIndex}"]`);
        const display = document.querySelector(`.gatePositionDisplay[data-i="${sideIndex}"]`);
        
        if (!checkbox.checked) return;
        
        let currentPosition = checkbox.dataset.gatePosition || 'middle';
        
        if (button.classList.contains('gateLeft')) {
          // Move left
          if (currentPosition === 'right') currentPosition = 'middle';
          else if (currentPosition === 'middle') currentPosition = 'left';
        } else {
          // Move right  
          if (currentPosition === 'left') currentPosition = 'middle';
          else if (currentPosition === 'middle') currentPosition = 'right';
        }
        
        checkbox.dataset.gatePosition = currentPosition;
        display.textContent = currentPosition.charAt(0).toUpperCase() + currentPosition.slice(1);
        
        console.log(`Gate position for side ${letters[sideIndex]} changed to: ${currentPosition}`);
        drawMini(); // Refresh preview
      };
    });
  }
  function segMini(id){
    if(id==='INLINE') return [{d:'M20 10 v80',cx:20,cy:50}];
    if(id==='L')      return [{d:'M20 10 v80',cx:20,cy:50},{d:'M20 10 h80',cx:60,cy:10}];
    if(id==='U')      return [{d:'M20 10 v100',cx:20,cy:60},{d:'M20 10 h80',cx:60,cy:10},{d:'M100 10 v100',cx:100,cy:60}];
    return [
      {d:'M20 10 v60',cx:20,cy:40},
      {d:'M20 10 h80',cx:60,cy:10},
      {d:'M100 10 v60',cx:100,cy:40},
      {d:'M20 70 h80',cx:60,cy:70}
    ];
  }
function drawMini(){
  console.log('drawMini called, curShape:', curShape);
  
  // Check if we have a valid shape and the diagram container exists
  if (!curShape || !curShape.id || curShape.id === 'CUSTOM') {
    console.log('No valid shape or is CUSTOM, skipping diagram');
    return;
  }
  
  const diagramContainer = $('shapeDiagram');
  if (!diagramContainer) {
    console.log('shapeDiagram container not found');
    return;
  }
  
  const NS='http://www.w3.org/2000/svg',svg=document.createElementNS(NS,'svg');
  svg.setAttribute('width',240);svg.setAttribute('height',200);  // Increased height to fit U-shape
  const offsetX = 40, offsetY = 30;  // Reduced offsetY to fit better

  // Find which input is focused
  let selectedIdx = -1;
  document.querySelectorAll('.spanLen').forEach(inp => {
    if (document.activeElement === inp) selectedIdx = +inp.dataset.i;
  });

  function segMini(id){
    if(id==='INLINE') return [{d:`M${offsetX+20} ${offsetY+10} v120`,cx:offsetX+20,cy:offsetY+70}];
    if(id==='L')      return [
      {d:`M${offsetX+20} ${offsetY+10} h120`,cx:offsetX+80,cy:offsetY+10},     // A - Top
      {d:`M${offsetX+140} ${offsetY+10} v120`,cx:offsetX+140,cy:offsetY+70}    // B - Right
    ];
    if(id==='U')      return [
      {d:`M${offsetX+20} ${offsetY+10} h120`,cx:offsetX+80,cy:offsetY+10},     // A - Top
      {d:`M${offsetX+140} ${offsetY+10} v120`,cx:offsetX+140,cy:offsetY+70},   // B - Right
      {d:`M${offsetX+20} ${offsetY+130} h120`,cx:offsetX+80,cy:offsetY+130}    // C - Bottom
    ];
    // BOX shape - Clockwise: A(top), B(right), C(bottom), D(left)
    return [
      {d:`M${offsetX+20} ${offsetY+10} h120`,cx:offsetX+80,cy:offsetY+10},      // A - Top
      {d:`M${offsetX+140} ${offsetY+10} v120`,cx:offsetX+140,cy:offsetY+70},    // B - Right
      {d:`M${offsetX+20} ${offsetY+130} h120`,cx:offsetX+80,cy:offsetY+130},    // C - Bottom
      {d:`M${offsetX+20} ${offsetY+10} v120`,cx:offsetX+20,cy:offsetY+70}       // D - Left
    ];
  }
  segMini(curShape.id).forEach((s,i)=>{
    const p=document.createElementNS(NS,'path');
    p.id=`seg${i}`;p.setAttribute('d',s.d);
    p.setAttribute('stroke', i===selectedIdx ? '#000' : '#888');
    p.setAttribute('stroke-width',8);
    svg.appendChild(p);

    // Check if this side has a gate
    const gateCheckbox = document.querySelector(`.gateRequired[data-i="${i}"]`);
    const hasGate = gateCheckbox && gateCheckbox.checked;
    
    // Gate visualization removed to keep shape diagram clean
    // (Gate information is shown in the side length inputs and elevation views)

    const t=document.createElementNS(NS,'text');
    t.id=`lbl${i}`;t.textContent=letters[i];
    // Label positions for BOX shape - Clockwise: A(top), B(right), C(bottom), D(left)
    if(curShape.id==='BOX'){
      if(i===0){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy-18); } // A - Top
      if(i===1){ t.setAttribute('x',s.cx+28); t.setAttribute('y',s.cy+24); } // B - Right
      if(i===2){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy+25); } // C - Bottom (moved up)
      if(i===3){ t.setAttribute('x',s.cx-28); t.setAttribute('y',s.cy+24); } // D - Left
    }else if(curShape.id==='U'){
      if(i===0){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy-18); } // A - Top
      if(i===1){ t.setAttribute('x',s.cx+28); t.setAttribute('y',s.cy+24); } // B - Right
      if(i===2){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy+25); } // C - Bottom (moved up)
    }else if(curShape.id==='L' && i===0){
      t.setAttribute('x',s.cx); t.setAttribute('y',s.cy-18);              // A - Top
    }else if(curShape.id==='L' && i===1){
      t.setAttribute('x',s.cx+28); t.setAttribute('y',s.cy+24);           // B - Right
    }else{
      t.setAttribute('x',s.cx + (i===0?-28:i===1?48:0));
      t.setAttribute('y',s.cy + (i===0?24:i===1?-18:0));
    }
    t.setAttribute('font-size','22');
    t.setAttribute('text-anchor','middle');
    t.setAttribute('fill', i===selectedIdx ? '#000' : '#888');
    svg.appendChild(t);
  });
  console.log('Appending SVG to shapeDiagram container');
  $('shapeDiagram').innerHTML='';$('shapeDiagram').appendChild(svg);
  console.log('Shape diagram updated successfully');
}
function refreshSelectors() {
  $('fenceType').addEventListener('change', refreshSelectors);
  $('windZone').addEventListener('change', refreshSelectors);
  $('glassThk').addEventListener('change', refreshSelectors);

  const pool = $('fenceType').value === 'pool',
        zone = $('windZone').value,
        thk = $('glassThk');

  // Save previous selection
  const prevThk = thk.value;

  // Set options - use 17.2 display for pool fence but keep 17.52 as value
  let opts;
  if (pool) {
    opts = [
      {value: '12', display: '12'},
      {value: '15', display: '15'},
      {value: '17.52', display: '17.2'}
    ];
  } else {
    // Balustrade
    opts = [
      {value: '12', display: '12'},
      {value: '13.52', display: '13.52'},
      {value: '15', display: '15'},
      {value: '17.52', display: '17.52'}
    ];
  }
  
  thk.innerHTML = opts.map(o => `<option value="${o.value}">${o.display}</option>`).join('');

  // Restore previous selection if still available, otherwise default to first option
  const availableValues = opts.map(o => o.value);
  if (availableValues.includes(prevThk)) {
    thk.value = prevThk;
  } else {
    thk.value = availableValues[0];
  }

  // Handle pool fence thickness restrictions by wind zone
  if(pool) {
    if (zone === 'VH' || zone === 'EH') {
      // 12mm not suitable for VH/EH
      const opt12 = thk.querySelector('option[value="12"]');
      if(opt12) opt12.disabled = true;
      if(thk.value === '12') thk.value = '15';
    }
    if (zone === 'EH') {
      // Only 17.52mm suitable for EH
      ['12', '15'].forEach(val => {
        const opt = thk.querySelector(`option[value="${val}"]`);
        if(opt) opt.disabled = true;
      });
      thk.value = '17.52';
    }
  } else {
    // Re-enable all options for balustrade
    opts.forEach(v => {
      const opt = thk.querySelector(`option[value="${v}"]`);
      if(opt) opt.disabled = false;
    });
  }

  document.querySelectorAll('#glassHt option')
    .forEach(o => o.disabled = pool && (+o.textContent < 1200 || +o.textContent > 1250));
  if(pool && (+$('glassHt').value < 1200 || +$('glassHt').value > 1250)) $('glassHt').value = '1200';

  // Save current handrail selection
  const handrailSelect = $('handrailType');
  const prevHandrail = handrailSelect.value;

  const t = thk.value;
  const isToughened = t === '12' || t === '15'; // Toughened glass is 12mm and 15mm
  const isSentryGlass = t === '13.52' || t === '17.52'; // Sentry glass is 13.52mm and 17.52mm
  const hrOpts = [];
  
  if(!pool){
    if (isSentryGlass) {
      // For balustrade with sentry glass (13.52mm and 17.52mm), CANNOT have handrail
      hrOpts.push({v:'none',txt:'No'});
    } else if (isToughened) {
      // For balustrade with toughened glass (12mm, 15mm), MUST have handrail - no "No" option
      // Only add S25 if thickness is exactly 12 (not for 15mm)
      if(t === '12') hrOpts.push({v:'S25',txt:'S25'});
      // Add other handrails for toughened glass (12mm, 15mm)
      ['S40','AH40','R40'].forEach(v => hrOpts.push({v,txt:v}));
    } else {
      // For other glass types in balustrade, allow "No" option
      hrOpts.push({v:'none',txt:'No'});
    }
  } else {
    // For pool fence, "No" option is always available
    hrOpts.push({v:'none',txt:'No'});
  }
  handrailSelect.innerHTML = hrOpts.map(o => `<option value="${o.v}">${o.txt}</option>`).join('');

  // Restore previous selection if still available
  if ([...handrailSelect.options].some(opt => opt.value === prevHandrail)) {
    handrailSelect.value = prevHandrail;
  } else if (!pool && isToughened && prevHandrail === 'none') {
    // For toughened glass in balustrade, auto-select first available handrail if "none" was previously selected
    handrailSelect.value = hrOpts.length > 0 ? hrOpts[0].v : '';
  } else if (isSentryGlass) {
    // For sentry glass (13.52mm and 17.52mm), always force "none" selection
    handrailSelect.value = 'none';
  }
}
  // ─── PS‑1 + solver ────────────────────────────────────────
  const PS1 = {
    balustrade: {
      overhang: 250,
      internal: {
        '12': {
          '950': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 400, M: 400, H: 400, VH: 400, EH: 400 } // Concrete and steel only
        },
        '13.52': {
          '950': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 400, M: 400, H: 400, VH: 400, EH: 400 } // Concrete and steel only
        },
        '15': {
          '950': { L: 475, M: 475, H: 475, VH: 475, EH: 475 },
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }, // Concrete and steel only
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }, // Concrete and steel only
          '1250': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }  // Concrete and steel only
        },
        '17.52': {
          '950': { L: 475, M: 475, H: 475, VH: 475, EH: 475 },
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }, // Concrete and steel only
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }, // Concrete and steel only
          '1250': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }  // Concrete and steel only
        }
      }
    },
    pool: {
      overhang: { '12': 500, '15': 500, '17.52': 500 },
      internal: {
        '12': {
          '1200': { L: 400, M: 400, H: 400, VH: 999, EH: 999 }, // Only up to H
          '1250': { L: 400, M: 400, H: 400, VH: 999, EH: 999 }  // Only up to H
        },
        '15': {
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 999 }, // Up to VH
          '1250': { L: 400, M: 400, H: 400, VH: 400, EH: 999 }  // Up to VH
        },
        '17.52': {
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }, // Up to EH
          '1250': { L: 400, M: 400, H: 400, VH: 400, EH: 400 }  // Up to EH
        }
      }
    }
  };
  const sym = (run,min,max,maxP) => {
    let cnt=Math.ceil(run/maxP);
    while(cnt<600){
      let pw=Math.min(maxP,Math.floor(run/cnt/50)*50);
      while(pw>=200){
        const gap=(run-pw*cnt)/(cnt+1);
        if(gap>=min&&gap<=max) return {panelWidths:Array(cnt).fill(pw),gap,run};
        pw-=50;
      }
      cnt++;
    }
    return null;
  };
  const mix = (run,min,max,maxP) => {
    let cnt=Math.ceil(run/maxP);
    while(cnt<600){
      for(let A=maxP;A>=200;A-=50){
        for(let B=A;B>=A-200;B-=50){
          for(let k=1;k<cnt;k++){
            const tot=(cnt-k)*A+k*B,
                  gap=(run-tot)/(cnt+1);
            if(gap>=min&&gap<=max){
              return {panelWidths:[...Array(cnt-k).fill(A),...Array(k).fill(B)],gap,run};
            }
          }
        }
      }
      cnt++;
    }
    return null;
  };
  const groupPanels = a => {
    const m={};a.forEach(w=>m[w]=(m[w]||0)+1);
    return Object.entries(m).map(([w,n])=>`${n}× @${w} mm`).join('<br>');
  };

  // ─── Calculate ─────────────────────────────────────────────
  $('calcBtn').onclick = function() {
    console.log('Calculate button clicked');
    
    const spans = [...document.querySelectorAll('.spanLen')].map(i => +i.value);
    console.log('Side lengths:', spans);
    
    if (spans.some(v => !v)) { 
      console.log('Missing side lengths');
      return alert('Enter every side length'); 
    }

    const fence = $('fenceType').value;
    const thk = $('glassThk').value;
    const ht = $('glassHt').value;
    const zone = $('windZone').value;
    const hr = $('handrailType').value;
    const fin = $('finishType').value;
    const fix = $('fixingType').value;
    const allowMix = $('allowMixed').checked;
    // SP14: Extra packers are not applicable; set to zero to avoid null errors
    const extraPackers = 0;

    console.log('Calculation inputs:', {fence, thk, ht, zone, hr, fin, fix});
    
    if (!thk) {
      console.log('No glass thickness selected');
      return alert('Please select glass thickness');
    }
    if (!ht) {
      console.log('No glass height selected');
      return alert('Please select glass height');
    }
    if (!zone) {
      console.log('No wind zone selected');
      return alert('Please select wind zone');
    }
    if (!fix) {
      console.log('No fixing type selected');
      return alert('Please select fixing type (substrate)');
    }
    
    const pool = fence === 'pool';
    const isToughened = thk === '12' || thk === '15'; // Toughened glass is 12mm and 15mm
    const isSentryGlass = thk === '13.52' || thk === '17.52'; // Sentry glass is 13.52mm and 17.52mm
    console.log('Pool check:', pool, 'HR value:', hr, 'Toughened glass:', isToughened, 'Sentry glass:', isSentryGlass);
    
    // Handrail validation rules:
    // - Balustrade with Sentry glass (13.52mm, 17.52mm): CANNOT have handrail
    // - Balustrade with Toughened glass (12mm, 15mm): MUST have handrail
    // - Pool fence: Optional handrail
    
    // Check if Sentry glass has a handrail selected (not allowed for balustrade)
    if (!pool && isSentryGlass && hr && hr !== 'none') {
      console.log('Handrail not allowed - Sentry glass detected');
      return alert('⚠️ Warning: Handrails are not permitted with Sentry glass (13.52mm or 17.52mm) in balustrade applications.\n\nPlease select "No" handrail or choose a different glass thickness.');
    }
    
    // Check if toughened glass requires handrail for balustrade
    if (!pool && isToughened && (!hr || hr === 'none')) {
      console.log('Handrail required - Toughened glass detected');
      return alert(`⚠️ Warning: Handrail selection is required for balustrade with toughened glass (12mm or 15mm thickness).\n\nToughened glass requires additional structural support. Please select an appropriate handrail option.`);
    }

    console.log('All inputs validated, continuing with calculation...');

    // Handle powdercoat color
    let finishSuffix = fin;
    let powdercoatColor = '';
    if (fin === 'PC') {
      powdercoatColor = $('powdercoatColor').value.trim();
      if (powdercoatColor) {
        finishSuffix = `PC-${powdercoatColor.replace(/\s+/g, '')}`;
      }
    }

    // Determine edge and internal spacing using SP14 PS1 lookup
    const system = pool ? 'pool' : 'balustrade';
    const ps1Row = typeof ps14Lookup === 'function' ? ps14Lookup(system, thk, ht, zone) : null;
    if (!ps1Row) {
      return alert(`⚠️ Warning: No SP14 PS1 data available for ${thk}mm glass at ${ht}mm height in ${zone} zone.\n\nThis combination is not within SP14 PS1 specification. Please change the thickness, height or wind zone to achieve compliance.`);
    }
    let edge = ps1Row.edge;
    if (typeof EDGE_MIN !== 'undefined' && edge < EDGE_MIN) edge = EDGE_MIN;
    let MAX_SPACING = ps1Row.internal;
    if (MAX_SPACING >= 999) {
      return alert(`⚠️ Warning: ${thk}mm glass at ${ht}mm height in ${zone} wind zone is not suitable for ${pool ? 'pool fence' : 'balustrade'} applications.\n\nThis combination exceeds SP14 PS1 structural limits. Please adjust your selections:\n• Try a different glass thickness\n• Try a different glass height\n• Try a lower wind zone if applicable`);
    }
    if (MAX_SPACING >= 999) {
      return alert(`⚠️ Warning: ${thk}mm glass at ${ht}mm height in ${zone} wind zone is not suitable for ${pool ? 'pool fence' : 'balustrade'} applications.\n\nThis combination exceeds SP14 PS1 structural limits. Please adjust your selections:\n• Try a different glass thickness\n• Try a different glass height\n• Try a lower wind zone if applicable`);
    }
    // Determine spigot mode (auto / 2 / 3)
    const spigotMode = (document.querySelector('input[name="spigotMode"]:checked') || {}).value || 'auto';
    let MAX_DISCS_PER_PANEL;
    if (spigotMode === '2') MAX_DISCS_PER_PANEL = 2;
    else if (spigotMode === '3') MAX_DISCS_PER_PANEL = 3;
    else MAX_DISCS_PER_PANEL = Infinity;

    // Max panel width by rails
    let cap = 2000;
    if (thk === '12' && hr === 'S25') cap = 1700;
    else if (hr === 'S40') cap = 1900;
    if (hr === 'SentryMax') cap = 1900;

    // Remove allow3Spigots option from UI
    const allow3El = document.getElementById('allow3Spigots');
    if (allow3El) allow3El.parentElement.style.display = 'none';

    // Dynamic gap and panel layout logic
    // Gap allowances per specification
    // Pool fences allow 10–60 mm gaps; balustrades allow 10–26 mm gaps
    const gMin = 10, gMax = fence === 'pool' ? 60 : 26;
    layouts = []; sideLens = spans;
    let total = 0, panels = [], posts = 0, rails = 0, gasket = 0, handrailMeters = 0;

    function sd50Sym(run, minGap, maxGap, maxPanel) {
      let cnt = Math.ceil(run / maxPanel);
      while (cnt < 600) {
        let pw = Math.min(maxPanel, Math.floor(run / cnt / 50) * 50);
        while (pw >= 200) {
          let discs = Math.max(2, Math.ceil((pw - 2 * edge) / MAX_SPACING) + 1);
          if (discs > MAX_DISCS_PER_PANEL) {
            pw = edge * 2 + (MAX_DISCS_PER_PANEL - 1) * MAX_SPACING;
            discs = MAX_DISCS_PER_PANEL;
          }
          let maxPanelWidth = edge * 2 + (discs - 1) * MAX_SPACING;
          if (pw > maxPanelWidth) pw = maxPanelWidth;
          const gap = (run - pw * cnt) / (cnt + 1);
          if (gap >= minGap && gap <= maxGap) {
            return { panelWidths: Array(cnt).fill(pw), gap, run };
          }
          pw -= 50;
        }
        cnt++;
      }
      return null;
    }
    function sd50Mix(run, minGap, maxGap, maxPanel) {
      let cnt = Math.ceil(run / maxPanel);
      while (cnt < 600) {
        for (let A = maxPanel; A >= 200; A -= 50) {
          for (let B = A; B >= A - 200; B -= 50) {
            for (let k = 1; k < cnt; k++) {
              let discsA = Math.max(2, Math.ceil((A - 2 * edge) / MAX_SPACING) + 1);
              let discsB = Math.max(2, Math.ceil((B - 2 * edge) / MAX_SPACING) + 1);
              if (discsA > MAX_DISCS_PER_PANEL) A = edge * 2 + (MAX_DISCS_PER_PANEL - 1) * MAX_SPACING;
              if (discsB > MAX_DISCS_PER_PANEL) B = edge * 2 + (MAX_DISCS_PER_PANEL - 1) * MAX_SPACING;
              const tot = (cnt - k) * A + k * B;
              const gap = (run - tot) / (cnt + 1);
              if (gap >= minGap && gap <= maxGap) {
                return { panelWidths: [...Array(cnt - k).fill(A), ...Array(k).fill(B)], gap, run };
              }
            }
          }
        }
        cnt++;
      }
      return null;
    }

    // Special layout finder for gate scenarios - accounts for reduced gap count
    function findGateAdjustedLayout(originalLen, minGap, maxGap, maxPanel, allowMixed) {
      // Create modified versions of sym and mix that account for fewer gaps
      const gateAdjustedSym = (run, min, max, maxP) => {
        let cnt = Math.ceil(run / maxP);
        while (cnt < 600) {
          let pw = Math.min(maxP, Math.floor(run / cnt / 50) * 50);
          while (pw >= 200) {
            // Modified gap calculation: cnt gaps instead of cnt+1 (gate replaces one gap)
            const gap = (run - pw * cnt) / cnt;
            if (gap >= min && gap <= max) return { panelWidths: Array(cnt).fill(pw), gap, run };
            pw -= 50;
          }
          cnt++;
        }
        return null;
      };

      const gateAdjustedMix = (run, min, max, maxP) => {
        let cnt = Math.ceil(run / maxP);
        while (cnt < 600) {
          for (let A = maxP; A >= 200; A -= 50) {
            for (let B = A; B >= A - 200; B -= 50) {
              for (let k = 1; k < cnt; k++) {
                const tot = (cnt - k) * A + k * B;
                // Modified gap calculation: cnt gaps instead of cnt+1
                const gap = (run - tot) / cnt;
                if (gap >= min && gap <= max) {
                  return { panelWidths: [...Array(cnt - k).fill(A), ...Array(k).fill(B)], gap, run };
                }
              }
            }
          }
          cnt++;
        }
        return null;
      };

      // First try the exact length
      let bestLayout = allowMixed
        ? (gateAdjustedMix(originalLen, minGap, maxGap, maxPanel) || gateAdjustedSym(originalLen, minGap, maxGap, maxPanel))
        : (gateAdjustedSym(originalLen, minGap, maxGap, maxPanel) || gateAdjustedMix(originalLen, minGap, maxGap, maxPanel));
      
      if (bestLayout) {
        bestLayout.adjustedLength = originalLen;
        bestLayout.adjustment = 0;
        return bestLayout;
      }

      // Try nudging ±1mm to ±5mm
      for (let nudge = 1; nudge <= 5; nudge++) {
        for (let direction of [-1, 1]) {
          const adjustedLen = originalLen + (direction * nudge);
          if (adjustedLen < 200) continue;
          
          const layout = allowMixed
            ? (gateAdjustedMix(adjustedLen, minGap, maxGap, maxPanel) || gateAdjustedSym(adjustedLen, minGap, maxGap, maxPanel))
            : (gateAdjustedSym(adjustedLen, minGap, maxGap, maxPanel) || gateAdjustedMix(adjustedLen, minGap, maxGap, maxPanel));
          
          if (layout) {
            if (!bestLayout || layout.panelWidths.length < bestLayout.panelWidths.length) {
              bestLayout = layout;
              bestLayout.adjustedLength = adjustedLen;
              bestLayout.adjustment = direction * nudge;
            }
          }
        }
        if (bestLayout) break;
      }
      
      return bestLayout;
    }

    // Enhanced solver with run length nudging for "unlucky" lengths
    function findBestLayout(originalLen, minGap, maxGap, maxPanel, allowMixed) {
      // First try the exact length
      let bestLayout = allowMixed
        ? (sd50Mix(originalLen, minGap, maxGap, maxPanel) || sd50Sym(originalLen, minGap, maxGap, maxPanel))
        : (sd50Sym(originalLen, minGap, maxGap, maxPanel) || sd50Mix(originalLen, minGap, maxGap, maxPanel));
      
      if (bestLayout) {
        bestLayout.adjustedLength = originalLen;
        bestLayout.adjustment = 0;
        return bestLayout;
      }

      // Try nudging ±1mm to ±5mm to find a better solution
      for (let nudge = 1; nudge <= 5; nudge++) {
        // Try shorter length first (fewer panels preferred)
        for (let direction of [-1, 1]) {
          const adjustedLen = originalLen + (direction * nudge);
          if (adjustedLen < 200) continue; // Don't go below minimum reasonable length
          
          const layout = allowMixed
            ? (sd50Mix(adjustedLen, minGap, maxGap, maxPanel) || sd50Sym(adjustedLen, minGap, maxGap, maxPanel))
            : (sd50Sym(adjustedLen, minGap, maxGap, maxPanel) || sd50Mix(adjustedLen, minGap, maxGap, maxPanel));
          
          if (layout) {
            // Prefer solutions with fewer panels (wider panels)
            if (!bestLayout || layout.panelWidths.length < bestLayout.panelWidths.length) {
              bestLayout = layout;
              bestLayout.adjustedLength = adjustedLen;
              bestLayout.adjustment = direction * nudge;
            }
          }
        }
        
        // If we found a solution with this nudge amount, return it
        if (bestLayout) break;
      }
      
      return bestLayout;
    }

    // Validate hinge panel size for gates
    function validateHingePanelSize(layout, gateSegment, gatePosition) {
      if (!layout || !gateSegment) return layout;
      
      console.log(`Validating hinge panel for gate at position: ${gatePosition}, hingeOnLeft: ${gateSegment.hingeOnLeft}`);
      
      // Allowed hinge panel sizes: 800-1500mm in 100mm increments
      const allowedHingeSizes = [800, 900, 1000, 1100, 1200, 1300, 1400, 1500];
      
      // Check if uniform panels is enabled - if so, skip hinge panel validation
      const uniformCheckbox = document.getElementById('uniformPanels');
      if (uniformCheckbox && uniformCheckbox.checked) {
        console.log('Uniform panels enabled - skipping hinge panel validation');
        return layout; // Allow uniform override
      }
      
      // Calculate gate panel index
      let gatePanelIndex;
      if (gateSegment.panelIndex !== undefined) {
        gatePanelIndex = gateSegment.panelIndex;
      } else {
        // Legacy support for position-based system
        const totalPanels = layout.panelWidths.length;
        
        if (gatePosition === 'left') {
          gatePanelIndex = Math.floor(totalPanels * 0.25); // 25% from left
        } else if (gatePosition === 'right') {
          gatePanelIndex = Math.floor(totalPanels * 0.75); // 75% from left  
        } else { // middle
          gatePanelIndex = Math.floor(totalPanels / 2); // 50% from left
        }
        
        // Update the gate segment with the calculated index for consistency
        gateSegment.panelIndex = gatePanelIndex;
      }
      
      // Determine hinge panel index based on gate position and hinge orientation
      const hingeOnLeft = gateSegment.hingeOnLeft !== undefined ? gateSegment.hingeOnLeft : false;
      let hingePanelIndex;
      
      if (hingeOnLeft) {
        // Hinge is on left side of gate, so hinge panel is the panel at the gate position
        // (since gate appears AFTER the panel in the drawing loop)
        hingePanelIndex = gatePanelIndex;
      } else {
        // Hinge is on right side of gate, so hinge panel is the next panel after gate
        hingePanelIndex = gatePanelIndex + 1;
      }
      
      console.log(`Gate panel index: ${gatePanelIndex}, Hinge panel index: ${hingePanelIndex}, Total panels: ${layout.panelWidths.length}`);
      
      // Store the hinge panel index in the gate segment for later reference
      gateSegment.hingePanelIndex = hingePanelIndex;
      
      // Check if hinge panel index is valid
      if (hingePanelIndex < 0 || hingePanelIndex >= layout.panelWidths.length) {
        console.warn(`Hinge panel index ${hingePanelIndex} is out of bounds. Gate at panel ${gatePanelIndex}, total panels: ${layout.panelWidths.length}`);
        return layout; // Can't validate if panel doesn't exist, but don't fail
      }
      
      const hingePanelSize = layout.panelWidths[hingePanelIndex];
      console.log(`Current hinge panel size: ${hingePanelSize}mm`);
      
      // Check if hinge panel size is valid
      if (!allowedHingeSizes.includes(hingePanelSize)) {
        // Try to find the closest allowed size
        const closest = allowedHingeSizes.reduce((prev, curr) => 
          Math.abs(curr - hingePanelSize) < Math.abs(prev - hingePanelSize) ? curr : prev
        );
        
        // If the difference is reasonable (within 200mm), adjust the panel
        if (Math.abs(closest - hingePanelSize) <= 200) {
          layout.panelWidths[hingePanelIndex] = closest;
          console.log(`Adjusted hinge panel (index ${hingePanelIndex}) from ${hingePanelSize}mm to ${closest}mm for gate compatibility. Gate at panel ${gatePanelIndex}, hinge on ${hingeOnLeft ? 'left' : 'right'}`);
        } else {
          // Panel size is too far from allowed range - but don't fail the whole operation
          console.warn(`Hinge panel size ${hingePanelSize}mm is not compatible with gate requirements. Allowed sizes: ${allowedHingeSizes.join(', ')}mm - continuing anyway`);
        }
      } else {
        console.log(`Hinge panel size ${hingePanelSize}mm (index ${hingePanelIndex}) is valid for gate requirements. Gate at panel ${gatePanelIndex}, hinge on ${hingeOnLeft ? 'left' : 'right'}`);
      }
      
      return layout; // Always return the layout, even if we couldn't optimize it
    }

    for (let i = 0; i < spans.length; i++) {
      const len = spans[i];
      let effectiveLength = len;
      let gateSegment = null;
      
      // Check if this side has a gate
      let gateRequired = false;
      if (curShape && curShape.id === 'CUSTOM') {
        // For custom shapes, check the custom gate checkboxes
        const customGateCheckbox = document.querySelector(`.customGateRequired[data-side="${i}"]`);
        gateRequired = customGateCheckbox && customGateCheckbox.checked;
        
        // Get custom gate position
        if (gateRequired && customGateCheckbox) {
          const customGatePosition = customGateCheckbox.dataset.gatePosition || 'middle';
          
          gateSegment = {
            type: 'gate',
            leafWidth: 890,
            hingeGap: 5,
            latchGap: 10,
            totalWidth: 905,
            sideIndex: i,
            position: customGatePosition,
            hingeOnLeft: false  // Default: hinge on right, latch on left
          };
        }
      } else {
        // For standard shapes, check the standard gate checkboxes
        const gateCheckbox = document.querySelector(`.gateRequired[data-i="${i}"]`);
        gateRequired = gateCheckbox && gateCheckbox.checked;
      }
      
      if (gateRequired) {
        // Gate dimensions: 890mm leaf + 5mm hinge clearance + 10mm latch clearance = 905mm total
        const GATE_TOTAL_WIDTH = 905;
        
        // Calculate effective length for fence portion
        effectiveLength = len - GATE_TOTAL_WIDTH;
        
        if (effectiveLength < 200) {
          return alert(`Side ${String.fromCharCode(65 + i)} is too short for a gate. Minimum required: ${GATE_TOTAL_WIDTH + 200}mm (gate + min panel width)`);
        }
        
        // Get gate position from UI
        const gateCheckbox = document.querySelector(`.gateRequired[data-i="${i}"]`);
        const gatePosition = gateCheckbox ? (gateCheckbox.dataset.gatePosition || 'middle') : 'middle';
        
        gateSegment = {
          type: 'gate',
          leafWidth: 890,
          hingeGap: 5,
          latchGap: 10,
          totalWidth: GATE_TOTAL_WIDTH,
          sideIndex: i,
          position: gatePosition,
          hingeOnLeft: false  // Default: hinge on right, latch on left
        };
        
        console.log(`Side ${String.fromCharCode(65 + i)}: Gate added (${GATE_TOTAL_WIDTH}mm) at ${gatePosition} position, fence portion: ${effectiveLength}mm`);
      }

      // For gate scenarios, we need to find a layout and validate hinge panel
      let lay;
      if (gateRequired) {
        // Try to find a layout where gap formula accounts for fewer gaps
        lay = findGateAdjustedLayout(effectiveLength, gMin, gMax, cap, allowMix);
        
        // Validate hinge panel size for gate compatibility
        if (lay && gateSegment) {
          const gatePosition = gateSegment.position || 'middle';
          lay = validateHingePanelSize(lay, gateSegment, gatePosition);
          
          if (!lay) {
            // If validation failed, try different nudging amounts or panel arrangements
            console.log(`Hinge panel validation failed, trying alternative layouts...`);
            
            // Try nudging in different directions to find a valid hinge panel size
            for (let nudge = 1; nudge <= 10; nudge++) {
              for (let direction of [-1, 1]) {
                const adjustedLen = effectiveLength + (direction * nudge);
                if (adjustedLen < 200) continue;
                
                const altLayout = findGateAdjustedLayout(adjustedLen, gMin, gMax, cap, allowMix);
                if (altLayout) {
                  const validatedLayout = validateHingePanelSize(altLayout, gateSegment, gatePosition);
                  if (validatedLayout) {
                    validatedLayout.adjustment = direction * nudge;
                    validatedLayout.adjustedLength = adjustedLen;
                    lay = validatedLayout;
                    console.log(`Found valid hinge panel layout with ${direction * nudge}mm adjustment`);
                    break;
                  }
                }
              }
              if (lay) break;
            }
          }
        }
      } else {
        lay = findBestLayout(effectiveLength, gMin, gMax, cap, allowMix);
      }
      
      if (!lay) {
        const errorMsg = gateRequired 
          ? `No compliant layout found for side ${String.fromCharCode(65 + i)} with gate. Check that hinge panel can be 800-1500mm (100mm increments) or enable uniform panels to override.`
          : `No compliant layout found even with ±5mm adjustment for side ${String.fromCharCode(65 + i)}`;
        return alert(errorMsg);
      }
      
      // Show adjustment info if length was nudged
      if (lay.adjustment !== 0) {
        console.log(`Run length ${effectiveLength}mm adjusted by ${lay.adjustment > 0 ? '+' : ''}${lay.adjustment}mm to ${lay.adjustedLength}mm for better panel layout`);
      }
      
      if (gateSegment) {
        lay.gateSegment = gateSegment;
        lay.originalLength = len;
      }
      
      layouts.push(lay);
      panels.push(...lay.panelWidths);
      total += lay.adjustedLength; // Use adjusted length for calculations
      
      // Debug: Log panel layout for each side
      console.log(`Side ${String.fromCharCode(65 + i)} (${len}mm): Panel widths = [${lay.panelWidths.join(', ')}], Gap = ${lay.gap}mm`);
      if (i === 2) { // Side C specific debug
        console.log(`Side C DEBUG: Original length=${len}, Effective length=${effectiveLength}, Adjusted length=${lay.adjustedLength}, Gate=${gateRequired}`);
      }
      
      // Calculate discs for each panel
      lay.panelWidths.forEach(pw => {
        let discs = Math.max(2, Math.ceil((pw - 2 * edge) / MAX_SPACING) + 1);
        posts += discs;
      });
      if (hr !== 'none') {
        rails = Math.ceil(total / 5800);
        gasket = Math.ceil(total / 1000);
        // Calculate total handrail length in meters for powdercoat charges
        handrailMeters = +(total / 1000).toFixed(1); // Convert to meters with 1 decimal
      }
    }

    // summary table
    // Compute total spigots (posts) including gate posts for SP14
    let gateCountTmp = 0;
    layouts.forEach((l) => { if (l.gateSegment) gateCountTmp++; });
    let discsTotal = posts + gateCountTmp * 2;
    // Group panel sizes and show disc count per size
    const panelSummary = (() => {
      const m = {};
      panels.forEach(w => m[w] = (m[w] || 0) + 1);
      return Object.entries(m)
        .map(([w, n]) => {
          let spigs = Math.max(2, Math.ceil((w - 2 * edge) / MAX_SPACING) + 1);
          return `${n} × @${w} mm (${spigs} spigots each)`;
        })
        .join('<br>');
    })();
    $('output').innerHTML=`
      <table class="results-table">
        <tr><th>Total run</th><td>${total} mm</td></tr>
        <tr><th>Panels</th><td>${panelSummary}</td></tr>
        <tr><th>Spigots</th><td>${discsTotal}</td></tr>
        <tr><th>Internal spacing</th><td>${MAX_SPACING} mm</td></tr>
        <tr><th>Edge spacing</th><td>${edge} mm</td></tr>
      </table>`;

    // order list
    const rows=[];
    // Compute total number of gates and posts (spigots) for SP14 order list
    let gateCountForPosts = 0;
    layouts.forEach((layout) => {
      if (layout.gateSegment) gateCountForPosts++;
    });
    const postsTotal = posts + gateCountForPosts * 2;
    // Add SP14 post codes (spigots) based on finish
    rows.push([`SP14-${finishSuffix}`, postsTotal]);
    // Add fixing kit codes for each post/spigot
    const fixKitMap = {
      // SP14 fixing kit codes: one kit per post
      'Concrete (Single Fix)': 'SP14FK-1',
      'Concrete (Double Fix)': 'SP14FK-2',
      'Steel Fix': 'SP14FK-3',
      'Timber Fix (Coach Screw)': 'SP14FK-4',
      'Timber Fix (Through Bolts)': 'SP14FK-5'
    };
    if (fix && fixKitMap[fix]) {
      rows.push([fixKitMap[fix], postsTotal]);
    }
    
    if(fix){
      console.log('Processing fixing components for:', JSON.stringify(fix));
      
      // Fixing kit quantities are handled in the SP14 order list above based on postsTotal.
    }
    if(hr!=='none'){
      // For powdercoated items, use base codes and add separate PC charges
      const baseCode = hr;
      const needsPowdercoat = fin === 'PC';
      
      // Rail suffix logic - all rails get suffixes, AH40 has Mill/Black/SS options
      let railSuf = '';
      if (needsPowdercoat) {
        // Default to Mill for powdercoating (or SSS for non-AH40)
        railSuf = hr === 'AH40' ? '-MILL' : '-SS';
      } else {
        // Standard finishes
        if (hr === 'AH40') {
          // AH40 available in MILL, BK, SS
          railSuf = fin === 'BK' ? '-BK' : fin === 'SS' ? '-SS' : '-MILL';
        } else {
          // S40, S25, R40 use standard suffixes
          railSuf = `-${fin}`;
        }
      }
      
      // Main handrail
      rows.push([baseCode + railSuf, rails]);
      
      if(gasket){
        const gc={'S25':'S25GR','S40':'S40GR1','AH40':'AHGR1','R40':'R40GR1'}[hr];
        rows.push([gc,gasket]);
      }
      
      // Joiners - use dynamic corner detection for custom shapes
      if (curShape && curShape.id === 'CUSTOM') {
        // Get detected corners and add appropriate joiners
        const corners = detectCornersAndJoiners();
        let ninetyDegreeCount = 0;
        let adjustableCount = 0;
        
        corners.forEach(corner => {
          if (corner.isNinetyDegree) {
            ninetyDegreeCount++;
          } else {
            adjustableCount++;
          }
        });
        
        // Add 90 degree corner joiners
        if (ninetyDegreeCount > 0) {
          if (hr === 'AH40') {
            rows.push(['AHJ90', ninetyDegreeCount]);
          } else {
            const joinerSuf = needsPowdercoat ? '-SS' : `-${fin}`;
            rows.push([baseCode + 'J90' + joinerSuf, ninetyDegreeCount]);
          }
        }
        
        // Add adjustable horizontal joiners
        if (adjustableCount > 0) {
          if (hr === 'AH40') {
            rows.push(['AHAHJ', adjustableCount]);
          } else {
            const joinerSuf = needsPowdercoat ? '-SS' : `-${fin}`;
            rows.push([baseCode + 'HAJ' + joinerSuf, adjustableCount]);
          }
        }
        
        // Always add straight joiners for connecting segments
        if (hr === 'AH40') {
          rows.push(['AHJ180', Math.ceil(rails/2)]);
        } else {
          const joinerSuf = needsPowdercoat ? '-SS' : `-${fin}`;
          rows.push([baseCode + 'J180' + joinerSuf, Math.ceil(rails/2)]);
        }
      } else {
        // Original logic for standard shapes
        if (hr === 'AH40') {
          // AH40 uses special joiner codes that don't get powdercoated
          rows.push(['AHJ180', Math.ceil(rails/2)]);
          const cj={'INLINE':0,'L':1,'U':2,'BOX':4}[curShape.id];
          if(cj) rows.push(['AHJ90', cj]);
        } else {
          // S40, S25, R40 get finish suffixes and can be powdercoated
          const joinerSuf = needsPowdercoat ? '-SS' : `-${fin}`;
          rows.push([baseCode + 'J180' + joinerSuf, Math.ceil(rails/2)]);
          const cj={'INLINE':0,'L':1,'U':2,'BOX':4}[curShape.id];
          if(cj) rows.push([baseCode + 'J90' + joinerSuf, cj]);
        }
      }
      
      // Wall attachments
      let needW=!(curShape.id==='BOX'&&fence!=='balustrade');
      if(needW){
        if(hr==='S40'||hr==='S25'){
          const walSuf = needsPowdercoat ? '-SS' : `-${fin}`;
          rows.push([baseCode + 'WAL' + walSuf, 1], [baseCode + 'WAR' + walSuf, 1]);
        } else if(hr==='R40'){
          const waSuf = needsPowdercoat ? '-SS' : `-${fin}`;
          rows.push(['R40WA' + waSuf, 2]);
        } else if(hr==='AH40'){
          // AH40 wall brackets available in SS and BK only (no Mill)
          const wbSuf = needsPowdercoat ? '-SS' : (fin === 'SS' ? '-SS' : '-BK');
          rows.push(['AHWB' + wbSuf, 2]);
        }
      }
      
      // Add powdercoat charges if needed
      if(needsPowdercoat) {
        const colorSuffix = powdercoatColor ? ` (${powdercoatColor})` : '';
        
        // PC-BRACKET for joiners and wall attachments (AH40 joiners don't get powdercoated)
        let bracketQty = 0;
        if (hr !== 'AH40') {
          bracketQty = Math.ceil(rails/2); // J180 qty
          
          if (curShape && curShape.id === 'CUSTOM') {
            // For custom shapes, count detected corners
            const corners = detectCornersAndJoiners();
            corners.forEach(corner => {
              bracketQty += 1; // Each corner needs powdercoating
            });
          } else {
            // Original logic for standard shapes
            const cj={'INLINE':0,'L':1,'U':2,'BOX':4}[curShape.id];
            if(cj) bracketQty += cj; // J90 qty
          }
        }
        
        if(needW) {
          if(hr==='S40'||hr==='S25') bracketQty += 2; // WAL + WAR
          else if(hr==='R40') bracketQty += 2; // R40WA qty
          else if(hr==='AH40') bracketQty += 2; // AHWB qty
        }
        if (bracketQty > 0) {
          rows.push([`PC-BRACKET${colorSuffix}`, bracketQty]);
        }
        
        // PC-PERM for main handrail (use total meters)
        rows.push([`PC-PERM${colorSuffix}`, handrailMeters]);
      }
    }

    // Count gates for handrail endcaps (process before gate hardware)
    let totalGates = 0;
    layouts.forEach((layout) => {
      if (layout.gateSegment) {
        totalGates++;
      }
    });

    // Add handrail endcaps for gates (2 per gate) - above gate hardware in order
    if (totalGates > 0 && hr !== 'none') {
      const endcapQty = totalGates * 2; // 2 endcaps per gate
      
      // Determine endcap codes based on handrail type
      let endcapCode = '';
      const needsPowdercoat = fin === 'PC';
      
      if (hr === 'S25') {
        endcapCode = needsPowdercoat ? 'S25EC-SS' : `S25EC-${fin}`;
      } else if (hr === 'S40') {
        endcapCode = needsPowdercoat ? 'S40EC-SS' : `S40EC-${fin}`;
      } else if (hr === 'AH40') {
        // AH40 endcaps use AHEC code, available in SS and BK only
        endcapCode = needsPowdercoat ? 'AHEC-SS' : (fin === 'SS' ? 'AHEC-SS' : 'AHEC-BK');
      } else if (hr === 'R40') {
        endcapCode = needsPowdercoat ? 'R40EC-SS' : `R40EC-${fin}`;
      }
      
      if (endcapCode) {
        rows.push([endcapCode, endcapQty]);
        console.log(`Added ${endcapQty} handrail endcaps (${endcapCode}) for ${totalGates} gates`);
        
        // Add powdercoat charge for endcaps if needed
        if (needsPowdercoat) {
          const colorSuffix = powdercoatColor ? ` (${powdercoatColor})` : '';
          rows.push([`PC-ENDCAP${colorSuffix}`, endcapQty]);
        }
      }
    }

    // Add extra packers if specified
    if (extraPackers > 0) {
      rows.push([`FG50-08`, extraPackers]);
      console.log('Added extra packers:', extraPackers);
    }

    // Add gate components aggregated by number of gates: one pair of hinges and one latch per gate
    {
      const gateCount = gateCountForPosts;
      if (gateCount > 0) {
        rows.push(['ASC180', gateCount]);
        rows.push(['PL180GG', gateCount]);
      }
    }

    const tb=document.querySelector('.order-table tbody');
    tb.innerHTML='';
    
    // Function to get description for item codes
    function getItemDescription(code) {
      // Custom description overrides for specific codes
      // Handrail endcaps and special components
      if (code === 'S25EC') return 'S25 Handrail Endcap';
      if (code === 'S40EC') return 'S25 Handrail Endcap';
      if (code === 'AH40') return 'AH40 Handrail Endcap';
      if (code === 'R40EC') return 'R40 Handrail endcap';

      // Wall attachments and anchors
      if (code === 'S40WAL') return 'S40 Wall Attachment Left';
      if (code === 'S40WAR') return 'S40 Wall Attachment Right';
      if (code.startsWith('R40WA')) return 'R40 Wall Anchor';

      // SP14 posts and fixing kits
      if ((code === 'SP14') || (code.startsWith('SP14') && !code.startsWith('SP14FK'))) return 'SP14 Side Fix Post';
      if (code === 'SP14FK-1') return 'SP14 Concrete Fixing Kit (Single Fix)';
      if (code === 'SP14FK-2') return 'SP14 Concrete Fixing Kit (Double Fix)';
      if (code === 'SP14FK-3') return 'SP14 Steel Fixing Kit';
      if (code === 'SP14FK-4') return 'SP14 Timber Fixing Kit (Coach Screws)';
      if (code === 'SP14FK-5') return 'SP14 Timber Fixing Kit (Through Bolts)';
      // Disc types - based on the UI labels found in the file
      if (code.includes('ASD50-SH')) return 'Adjustable Screw Head Standoff Disc';
      if (code.includes('ASD50-FH')) return 'Adjustable Flat Head Standoff Disc';
      if (code.includes('ASD50-BH')) return 'Adjustable Bevelled Head Standoff Disc';
      if (code.includes('ASD50-DH')) return 'Adjustable Double Head Standoff Disc';
      if (code.includes('ASD50')) return 'Adjustable Standoff Disc';
      if (code.includes('SD50-SH')) return 'Screw Head Standoff Disc (CSK)';
      if (code.includes('SD50-DH')) return 'Double Head Standoff Disc';
      if (code.includes('SD50-FH')) return 'Flat Head Standoff Disc (Concealed)';
      if (code.includes('SD50-BH')) return 'Bevelled Head Standoff Disc';
      
      // Powdercoating
      if (code.startsWith('PC1-DISC')) return 'Disc Powdercoating';
      if (code.startsWith('PC1-RAIL')) return 'Rail Powdercoating';
      
      // Fixing components - exact descriptions based on code analysis
      if (code === 'TR10-140') return 'Concrete Anchor (M10 x 140mm)';
      if (code === 'TR10-60') return 'Steel Fixing Bolt (M10 x 60mm)';
      if (code === 'TR10-150') return 'Timber Bolt (M10 x 150mm)';
      if (code === 'HN-M10') return 'Hex Nut M10';
      if (code === 'FW-M1224') return 'Flat Washer M10';
      if (code === 'FWSQ-M12-G') return 'Square Washer M12 Galvanised';
      if (code === 'TL2650') return 'LocTite Adhesive';
      if (code === 'LS10-100') return 'M10 Lag Screws (M10 x 100mm)';
      if (code === 'SIKA-NSG30') return 'SIKA Nailbond Supergrip Adhesive 30 minute';
      
      // Handrails - handle base codes and codes with suffixes
      if (code.startsWith('S25') && !code.includes('GR') && !code.includes('J') && !code.includes('WAL') && !code.includes('WAR')) {
        return 'S25 Square Handrail (25x25mm)';
      }
      if (code.startsWith('S40') && !code.includes('GR') && !code.includes('J')) {
        return 'S40 Square Handrail (40x40mm)';
      }
      if (code.startsWith('AH40') && !code.includes('GR') && !code.includes('J')) {
        return 'AH40 Aluminium Handrail';
      }
      if (code.startsWith('R40') && !code.includes('GR') && !code.includes('J')) {
        return 'R40 Round Handrail (40mm dia)';
      }
      
      // Gaskets - exact matches first
      if (code === 'S25GR') return 'S25 Handrail Gasket';
      if (code === 'S40GR1') return 'S40 Handrail Gasket';
      if (code === 'AHGR1') return 'AH40 Aluminium Handrail Gasket';
      if (code === 'R40GR1') return 'R40 Handrail Gasket';
      if (code.includes('GR-GATE')) return 'Gate Handrail Gasket';
      if (code.endsWith('-GATE') && code.includes('GR')) return 'Gate Handrail Gasket';
      
      // Joiners - comprehensive matching for all handrail types
      if (code === 'AHJ180') return 'AH40 Aluminium Handrail Straight Joiner (180°)';
      if (code === 'AHJ90') return 'AH40 Aluminium Handrail 90° Corner Joiner';
      if (code === 'AHAHJ') return 'AH40 Aluminium Handrail Adjustable Horizontal Joiner';
      
      // S40 joiners
      if (code.startsWith('S40J180')) return 'S40 Straight Joiner (180°)';
      if (code.startsWith('S40J90')) return 'S40 90° Corner Joiner';
      if (code.startsWith('S40HAJ')) return 'S40 Adjustable Horizontal Joiner';
      
      // S25 joiners  
      if (code.startsWith('S25J180')) return 'S25 Straight Joiner (180°)';
      if (code.startsWith('S25J90')) return 'S25 90° Corner Joiner';
      if (code.startsWith('S25HAJ')) return 'S25 Adjustable Horizontal Joiner';
      
      // R40 joiners
      if (code.startsWith('R40J180')) return 'R40 Straight Joiner (180°)';
      if (code.startsWith('R40J90')) return 'R40 90° Corner Joiner';
      if (code.startsWith('R40HAJ')) return 'R40 Adjustable Horizontal Joiner';
      
      // Generic joiner fallbacks (should catch any remaining patterns)
      if (code.includes('J180')) return 'Straight Joiner (180°)';
      if (code.includes('J90')) return '90° Corner Joiner';
      if (code.includes('HAJ')) return 'Adjustable Horizontal Joiner';
      if (code.includes('CJ')) return 'Corner Joiner';
      
      // Wall attachment components
      if (code.startsWith('S40WAL')) return 'S40 Wall Attachment Left';
      if (code.startsWith('S40WAR')) return 'S40 Wall Attachment Right';
      if (code.startsWith('S25WAL')) return 'S25 Wall Attachment Left';
      if (code.startsWith('S25WAR')) return 'S25 Wall Attachment Right';
      if (code.startsWith('R40WA')) return 'R40 Wall Anchor';
      if (code.startsWith('AHWB')) return 'AH40 Aluminium Handrail Wall Bracket';
      
      // Generic wall attachment fallbacks
      if (code.includes('WAL')) return 'Wall Attachment Left';
      if (code.includes('WAR')) return 'Wall Attachment Right';
      if (code.includes('WA')) return 'Wall Attachment';
      if (code.includes('WB')) return 'Wall Bracket';
      
      // Extra packers
      if (code === 'FG50-08') return 'Fiber Gasket, 50mmDia x 0.8mm';
      
      // Gate hardware - with finish suffix handling
      if (code.startsWith('ASC180')) {
        let desc = 'Atlantic Soft Close Hinge G2G 180° (Pair)';
        if (code.endsWith('-SS')) desc += ' - Stainless Steel';
        else if (code.endsWith('-BK')) desc += ' - Black';
        else if (code.endsWith('-PS')) desc += ' - Powder Coated Stainless';
        return desc;
      }
      if (code.startsWith('PL180GG')) {
        let desc = 'Pool Gate Latch G2G 180°';
        if (code.endsWith('-SS')) desc += ' - Stainless Steel';
        else if (code.endsWith('-BK')) desc += ' - Black';
        else if (code.endsWith('-PS')) desc += ' - Powder Coated Stainless';
        return desc;
      }
      
      // Catch any remaining gate codes
      if (code.startsWith('GATE-')) return 'Gate Hardware Component';
      
      // Default fallback - but this should rarely be used now
      return 'Hardware Component';
    }
    
    rows.forEach(([c,q])=>{
      const description = getItemDescription(c);
      tb.insertAdjacentHTML('beforeend',`<tr><td>${description}</td><td>${c}</td><td>${q}</td></tr>`);
    });
    $('orderList').style.display='';
    drawRows();
  };

  // ─── Redraw single elevation (preserves scroll position) ───
  function redrawSingleElevation(sideIndex, lay) {
    const NS = 'http://www.w3.org/2000/svg';
    
    // Find the existing view element for this side
    const allViews = document.querySelectorAll('#visual .view');
    if (!allViews[sideIndex]) return;
    
    const viewElement = allViews[sideIndex];
    
    // Clear existing SVG
    viewElement.innerHTML = '';
    
    // Recreate the SVG for this specific side
    const gPx = lay.gap * PX;
    const actualLength = lay.gateSegment ? sideLens[sideIndex] : (lay.adjustedLength || sideLens[sideIndex]);
    const svgW = actualLength * PX + MAR * 2;
    const svgH = 140;
    const svg = document.createElementNS(NS, 'svg');
    svg.setAttribute('width', svgW);
    svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);

    let x = MAR;
    
    // Draw initial gap
    (() => {
      const r = document.createElementNS(NS, 'rect');
      r.setAttribute('x', x); r.setAttribute('y', 20);
      r.setAttribute('width', gPx); r.setAttribute('height', 100);
      r.setAttribute('fill', '#ddd');
      svg.appendChild(r);
      const t = document.createElementNS(NS, 'text');
      t.textContent = rnd(lay.gap);
      t.setAttribute('x', x + gPx / 2); t.setAttribute('y', 16);
      t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '12');
      t.setAttribute('font-weight', 'bold');
      t.setAttribute('fill', '#0077c8');
      svg.appendChild(t);
      x += gPx;
    })();

    // Draw panels and gates
    lay.panelWidths.forEach((pw, panelIndex) => {
      // Check if this panel position is where the gate should be placed
      let isGatePosition = false;
      let isHingePanelPosition = false;
      
      if (lay.gateSegment) {
        const gatePanelIndex = lay.gateSegment.panelIndex !== undefined 
          ? lay.gateSegment.panelIndex 
          : Math.floor(lay.panelWidths.length / 2);
        
        isGatePosition = (panelIndex === gatePanelIndex);
        
        // Check for wall-to-glass conditions
        const totalPanels = lay.panelWidths.length;
        const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
        const isWallToGlassHinge = (gatePanelIndex === 0 && hingeOnLeft); // Gate at start, hinge to wall
        const isWallToGlassLatch = (gatePanelIndex === totalPanels - 1 && !hingeOnLeft); // Gate at end, latch to wall
        
        // Use direct hinge panel index tracking if available, but skip for wall-to-glass hinge
        if (lay.gateSegment.hingePanelIndex !== undefined && !isWallToGlassHinge) {
          isHingePanelPosition = (panelIndex === lay.gateSegment.hingePanelIndex);
        } else if (!isWallToGlassHinge) {
          // Fallback to calculation for initial setup (but not for wall-to-glass)
          if (hingeOnLeft) {
            isHingePanelPosition = (panelIndex === gatePanelIndex);
          } else {
            isHingePanelPosition = (panelIndex === gatePanelIndex + 1);
          }
        }
        // If wall-to-glass hinge, no hinge panel is drawn
        
        if (panelIndex === 0 || panelIndex === gatePanelIndex || panelIndex === gatePanelIndex - 1 || panelIndex === gatePanelIndex + 1) {
          console.log(`Panel ${panelIndex}: Gate=${isGatePosition}, Hinge=${isHingePanelPosition}, GateIndex=${gatePanelIndex}, HingeIndex=${lay.gateSegment.hingePanelIndex}, WallHinge=${isWallToGlassHinge}, WallLatch=${isWallToGlassLatch}`);
        }
      }
      
      if (isHingePanelPosition) {
        // This is the hinge panel - draw it with special styling
        console.log(`Drawing HINGE PANEL at position ${panelIndex} with width ${pw}mm`);
        const w = pw * PX;
        const r = document.createElementNS(NS, 'rect');
        r.setAttribute('x', x); r.setAttribute('y', 20);
        r.setAttribute('width', w); r.setAttribute('height', 100);
        r.setAttribute('fill', '#d6f0ff'); // Light blue-tint for hinge panel
        r.setAttribute('stroke', '#333');
        r.setAttribute('stroke-width', '2');
        svg.appendChild(r);
        
        // Add "HINGE" label inside the rectangle (like the gate has "GATE")
        const hingeLabel = document.createElementNS(NS, 'text');
        hingeLabel.textContent = 'HINGE';
        hingeLabel.setAttribute('x', x + w / 2); hingeLabel.setAttribute('y', 75);
        hingeLabel.setAttribute('text-anchor', 'middle'); hingeLabel.setAttribute('font-size', '14');
        hingeLabel.setAttribute('font-weight', 'bold');
        hingeLabel.setAttribute('fill', '#0066cc'); // Blue text to match the blue theme
        svg.appendChild(hingeLabel);
        
        // Size label underneath (keep existing)
        const t = document.createElementNS(NS, 'text');
        t.textContent = `Hinge Panel ${pw}`;
        t.setAttribute('x', x + w / 2); t.setAttribute('y', 105);
        t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '12');
        t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', '#333');
        svg.appendChild(t);
        x += w;
        
        // Add gap after hinge panel - this becomes the 5mm hinge gap
        const gPx = 5 * PX; // Force 5mm gap for hinge
        const gapR = document.createElementNS(NS, 'rect');
        gapR.setAttribute('x', x); gapR.setAttribute('y', 20);
        gapR.setAttribute('width', gPx); gapR.setAttribute('height', 100);
        gapR.setAttribute('fill', '#ffff99'); gapR.setAttribute('stroke', '#666'); // Yellow for hinge gap
        svg.appendChild(gapR);
        const gapT = document.createElementNS(NS, 'text');
        gapT.textContent = '5mm H';
        gapT.setAttribute('x', x + gPx / 2); gapT.setAttribute('y', 75);
        gapT.setAttribute('text-anchor', 'middle'); gapT.setAttribute('font-size', '10');
        gapT.setAttribute('fill', '#666');
        svg.appendChild(gapT);
        x += gPx;
        
      } else if (isGatePosition) {
        // This is the gate position - draw the 890mm gate with wall-to-glass logic
        console.log(`Drawing GATE at position ${panelIndex}`);
        
        // Check for wall-to-glass conditions
        const totalPanels = lay.panelWidths.length;
        const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
        const isWallToGlassHinge = (panelIndex === 0 && hingeOnLeft); // Gate at start, hinge to wall
        const isWallToGlassLatch = (panelIndex === totalPanels - 1 && !hingeOnLeft); // Gate at end, latch to wall
        
        // Draw hinge gap before gate (if not wall-to-glass hinge)
        if (!isWallToGlassHinge) {
          const hingeGapW = 5 * PX; // Standard 5mm hinge gap
          const hingeGapR = document.createElementNS(NS, 'rect');
          hingeGapR.setAttribute('x', x); hingeGapR.setAttribute('y', 20);
          hingeGapR.setAttribute('width', hingeGapW); hingeGapR.setAttribute('height', 100);
          hingeGapR.setAttribute('fill', '#ffff99'); hingeGapR.setAttribute('stroke', '#666');
          svg.appendChild(hingeGapR);
          const hingeGapT = document.createElementNS(NS, 'text');
          hingeGapT.textContent = '5mm H';
          hingeGapT.setAttribute('x', x + hingeGapW / 2); hingeGapT.setAttribute('y', 75);
          hingeGapT.setAttribute('text-anchor', 'middle'); hingeGapT.setAttribute('font-size', '10');
          hingeGapT.setAttribute('fill', '#666');
          svg.appendChild(hingeGapT);
          x += hingeGapW;
        } else {
          // Wall-to-glass hinge: 7mm gap to wall
          const wallHingeGapW = 7 * PX;
          const wallHingeGapR = document.createElementNS(NS, 'rect');
          wallHingeGapR.setAttribute('x', x); wallHingeGapR.setAttribute('y', 20);
          wallHingeGapR.setAttribute('width', wallHingeGapW); wallHingeGapR.setAttribute('height', 100);
          wallHingeGapR.setAttribute('fill', '#ff9999'); wallHingeGapR.setAttribute('stroke', '#666'); // Different color for wall gap
          svg.appendChild(wallHingeGapR);
          const wallHingeGapT = document.createElementNS(NS, 'text');
          wallHingeGapT.textContent = '7mm WH';
          wallHingeGapT.setAttribute('x', x + wallHingeGapW / 2); wallHingeGapT.setAttribute('y', 75);
          wallHingeGapT.setAttribute('text-anchor', 'middle'); wallHingeGapT.setAttribute('font-size', '10');
          wallHingeGapT.setAttribute('fill', '#666');
          svg.appendChild(wallHingeGapT);
          x += wallHingeGapW;
        }
        
        // Draw the gate
        const gateW = 890 * PX;
        const gateR = document.createElementNS(NS, 'rect');
        gateR.setAttribute('x', x); gateR.setAttribute('y', 20);
        gateR.setAttribute('width', gateW); gateR.setAttribute('height', 100);
        gateR.setAttribute('fill', '#90EE90'); gateR.setAttribute('stroke', '#333');
        gateR.setAttribute('stroke-width', '2');
        svg.appendChild(gateR);
        const gateT = document.createElementNS(NS, 'text');
        gateT.textContent = isWallToGlassHinge || isWallToGlassLatch ? 'WALL-GATE' : 'GATE';
        gateT.setAttribute('x', x + gateW / 2); gateT.setAttribute('y', 75);
        gateT.setAttribute('text-anchor', 'middle'); gateT.setAttribute('font-size', '14');
        gateT.setAttribute('font-weight', 'bold');
        gateT.setAttribute('fill', '#006400');
        svg.appendChild(gateT);
        x += gateW;
        
        // Draw latch gap after gate
        if (isWallToGlassLatch) {
          // Wall-to-glass latch: 7.5mm gap to wall
          const wallLatchGapW = 7.5 * PX;
          const wallLatchGapR = document.createElementNS(NS, 'rect');
          wallLatchGapR.setAttribute('x', x); wallLatchGapR.setAttribute('y', 20);
          wallLatchGapR.setAttribute('width', wallLatchGapW); wallLatchGapR.setAttribute('height', 100);
          wallLatchGapR.setAttribute('fill', '#ffb366'); wallLatchGapR.setAttribute('stroke', '#666'); // Different color for wall latch
          svg.appendChild(wallLatchGapR);
          const wallLatchGapT = document.createElementNS(NS, 'text');
          wallLatchGapT.textContent = '7.5mm WL';
          wallLatchGapT.setAttribute('x', x + wallLatchGapW / 2); wallLatchGapT.setAttribute('y', 75);
          wallLatchGapT.setAttribute('text-anchor', 'middle'); wallLatchGapT.setAttribute('font-size', '10');
          wallLatchGapT.setAttribute('fill', '#666');
          svg.appendChild(wallLatchGapT);
          x += wallLatchGapW;
        } else {
          // Standard 10mm latch gap
          const latchGapW = 10 * PX;
          const latchGapR = document.createElementNS(NS, 'rect');
          latchGapR.setAttribute('x', x); latchGapR.setAttribute('y', 20);
          latchGapR.setAttribute('width', latchGapW); latchGapR.setAttribute('height', 100);
          latchGapR.setAttribute('fill', '#ffcc99'); latchGapR.setAttribute('stroke', '#666');
          svg.appendChild(latchGapR);
          const latchGapT = document.createElementNS(NS, 'text');
          latchGapT.textContent = '10mm L';
          latchGapT.setAttribute('x', x + latchGapW / 2); latchGapT.setAttribute('y', 75);
          latchGapT.setAttribute('text-anchor', 'middle'); latchGapT.setAttribute('font-size', '10');
          latchGapT.setAttribute('fill', '#666');
          svg.appendChild(latchGapT);
          x += latchGapW;
        }
        
      } else {
        // Regular panel
        const w = pw * PX;
        const r = document.createElementNS(NS, 'rect');
        r.setAttribute('x', x); r.setAttribute('y', 20);
        r.setAttribute('width', w); r.setAttribute('height', 100);
        r.setAttribute('fill', '#a8d6ff'); 
        r.setAttribute('stroke', '#333');
        svg.appendChild(r);
        const t = document.createElementNS(NS, 'text');
        t.textContent = pw;
        t.setAttribute('x', x + w / 2); t.setAttribute('y', 105);
        t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '12');
        t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', '#333');
        svg.appendChild(t);
        x += w;
        
        // Add normal gap after regular panel 
        const gPx = lay.gap * PX;
        const r2 = document.createElementNS(NS, 'rect');
        r2.setAttribute('x', x); r2.setAttribute('y', 20);
        r2.setAttribute('width', gPx); r2.setAttribute('height', 100);
        r2.setAttribute('fill', '#e8e8e8'); r2.setAttribute('stroke', '#666');
        svg.appendChild(r2);
        const t2 = document.createElementNS(NS, 'text');
        t2.textContent = rnd(lay.gap);
        t2.setAttribute('x', x + gPx / 2); t2.setAttribute('y', 75);
        t2.setAttribute('text-anchor', 'middle'); t2.setAttribute('font-size', '10');
        t2.setAttribute('fill', '#666');
        svg.appendChild(t2);
        x += gPx;
      }
    });

    viewElement.appendChild(svg);
  }

  // ─── Scroll-preserving wrapper for drawRows ─────────────────────────────────
  function drawRowsPreserveScroll() {
    // Save scroll position to global variables for drawRows to restore
    window.savedScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    window.savedScrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
    
    console.log(`Saving scroll position to globals: top=${window.savedScrollTop}, left=${window.savedScrollLeft}`);
    
    // Call the original drawRows (which will restore at the end)
    drawRows();
  }

  // ─── Draw the little rows ─────────────────────────────────
  function drawRows(){
    console.log('drawRows function called');
    
    // Don't draw elevation views if we're on the shape picker screen
    const calcCard = $('calcCard');
    const shapePicker = $('shapePicker');
    if (!calcCard || calcCard.style.display === 'none' || 
        !shapePicker || shapePicker.style.display !== 'none') {
      console.log('Skipping drawRows - not in calculation mode');
      return;
    }
    
    // Don't draw if we don't have valid layouts data
    if (!layouts || layouts.length === 0) {
      console.log('Skipping drawRows - no layouts data');
      return;
    }
    
    /* ── 1. remember where the user was ───────────────────── */
    const visual = $('visual');
    const savedTop = visual.scrollTop;                       // vertical
    const savedLefts = [...visual.querySelectorAll('.view')]
                        .map(v => v.scrollLeft);             // per-side H-scroll
    console.log(`Saving scroll positions: top=${savedTop}, lefts=[${savedLefts.join(',')}]`);
    
    /* ── 2. do the usual rebuild ──────────────────────────── */
    visual.innerHTML = '';
    
    const NS='http://www.w3.org/2000/svg';
    layouts.forEach((lay,i)=>{
      const wrap=document.createElement('div');
      wrap.style.margin='1rem 0';
      wrap.innerHTML=`<div style="font-weight:600;margin-bottom:4px">
        Side ${letters[i]} (${sideLens[i]} mm)
      </div><div class="view"></div>`;
      $('visual').appendChild(wrap);

      const gPx=lay.gap*PX,
            // Use original side length for SVG width when gate is present, otherwise use adjusted length
            actualLength = lay.gateSegment ? sideLens[i] : (lay.adjustedLength || sideLens[i]),
            svgW=actualLength*PX+MAR*2,
            svgH=140,
            svg=document.createElementNS(NS,'svg');
      svg.setAttribute('width',svgW);
      svg.setAttribute('viewBox',`0 0 ${svgW} ${svgH}`);

     

      let x=MAR;
      ;(function(){
        const r=document.createElementNS(NS,'rect');
        r.setAttribute('x',x);r.setAttribute('y',20);
        r.setAttribute('width',gPx);r.setAttribute('height',100);
        r.setAttribute('fill','#ddd');
        svg.appendChild(r);
        const t=document.createElementNS(NS,'text');
        t.textContent=rnd(lay.gap);
        t.setAttribute('x',x+gPx/2);t.setAttribute('y',16);
        t.setAttribute('text-anchor','middle');t.setAttribute('font-size','12');
        t.setAttribute('font-weight','bold');
        t.setAttribute('fill','#0077c8');
        svg.appendChild(t);
        x+=gPx;
      })();

      lay.panelWidths.forEach((pw, panelIndex) => {
        const w=pw*PX;
        const r=document.createElementNS(NS,'rect');
        r.setAttribute('x',x);r.setAttribute('y',20);
        r.setAttribute('width',w);r.setAttribute('height',100);
        r.setAttribute('fill','#a8d6ff');r.setAttribute('stroke','#333');
        svg.appendChild(r);
        const t=document.createElementNS(NS,'text');
        t.textContent=pw;
        t.setAttribute('x',x+w/2);t.setAttribute('y',105);
        t.setAttribute('text-anchor','middle');t.setAttribute('font-size','12');
        t.setAttribute('font-weight','bold');
        t.setAttribute('fill','#333');
        svg.appendChild(t);
        x+=w;

        // Check if this panel is where the gate should be placed
        let gatePanelIndex = null;
        if (lay.gateSegment) {
          // Use panel index if available, otherwise fall back to position-based calculation
          if (lay.gateSegment.panelIndex !== undefined) {
            gatePanelIndex = lay.gateSegment.panelIndex;
          } else {
            // Legacy support for position-based system
            const totalPanels = lay.panelWidths.length;
            const position = lay.gateSegment.position || 'middle';
            
            if (position === 'left') {
              gatePanelIndex = Math.floor(totalPanels * 0.25); // 25% from left
            } else if (position === 'right') {
              gatePanelIndex = Math.floor(totalPanels * 0.75); // 75% from left  
            } else { // middle
              gatePanelIndex = Math.floor(totalPanels / 2); // 50% from left
            }
          }
        }
        
        if (lay.gateSegment && panelIndex === gatePanelIndex) {
          // Draw gate elements with dynamic orientation based on hingeOnLeft
          const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
          
          if (hingeOnLeft) {
            // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
            
            // 5mm hinge clearance
            const hingeW = 5 * PX;
            const hingeR = document.createElementNS(NS,'rect');
            hingeR.setAttribute('x',x);hingeR.setAttribute('y',20);
            hingeR.setAttribute('width',hingeW);hingeR.setAttribute('height',100);
            hingeR.setAttribute('fill','#ffcccc');hingeR.setAttribute('stroke','#666');
            svg.appendChild(hingeR);
            const hingeT = document.createElementNS(NS,'text');
            hingeT.textContent='5mm H';
            hingeT.setAttribute('x',x+hingeW/2);hingeT.setAttribute('y',16);
            hingeT.setAttribute('text-anchor','middle');hingeT.setAttribute('font-size','9');
            hingeT.setAttribute('fill','#666');
            svg.appendChild(hingeT);
            x += hingeW;

            // 890mm gate panel
            const gateW = 890 * PX;
            const gateR = document.createElementNS(NS,'rect');
            gateR.setAttribute('x',x);gateR.setAttribute('y',20);
            gateR.setAttribute('width',gateW);gateR.setAttribute('height',100);
            gateR.setAttribute('fill','#90EE90');gateR.setAttribute('stroke','#333');
            gateR.setAttribute('stroke-width','2');
            svg.appendChild(gateR);
            const gateT = document.createElementNS(NS,'text');
            gateT.textContent='890mm GATE';
            gateT.setAttribute('x',x+gateW/2);gateT.setAttribute('y',75);
            gateT.setAttribute('text-anchor','middle');gateT.setAttribute('font-size','14');
            gateT.setAttribute('font-weight','bold');
            gateT.setAttribute('fill','#006400');
            svg.appendChild(gateT);
            
            // Add hinge graphics on the left side of gate
            const hingeGraphic1 = document.createElementNS(NS,'rect');
            hingeGraphic1.setAttribute('x', x - 3);
            hingeGraphic1.setAttribute('y', 35);
            hingeGraphic1.setAttribute('width', 8);
            hingeGraphic1.setAttribute('height', 15);
            hingeGraphic1.setAttribute('fill', '#333');
            hingeGraphic1.setAttribute('stroke', '#000');
            hingeGraphic1.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic1);
            
            const hingeGraphic2 = document.createElementNS(NS,'rect');
            hingeGraphic2.setAttribute('x', x - 3);
            hingeGraphic2.setAttribute('y', 80);
            hingeGraphic2.setAttribute('width', 8);
            hingeGraphic2.setAttribute('height', 15);
            hingeGraphic2.setAttribute('fill', '#333');
            hingeGraphic2.setAttribute('stroke', '#000');
            hingeGraphic2.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic2);
            
            // Add latch graphic on the right side of gate
            const latchGraphic = document.createElementNS(NS,'rect');
            latchGraphic.setAttribute('x', x + gateW - 15);
            latchGraphic.setAttribute('y', 63);
            latchGraphic.setAttribute('width', 12);
            latchGraphic.setAttribute('height', 12);
            latchGraphic.setAttribute('fill', '#333');
            latchGraphic.setAttribute('stroke', '#000');
            latchGraphic.setAttribute('stroke-width', '2');
            svg.appendChild(latchGraphic);
            
            x += gateW;

            // 10mm latch clearance
            const latchW = 10 * PX;
            const latchR = document.createElementNS(NS,'rect');
            latchR.setAttribute('x',x);latchR.setAttribute('y',20);
            latchR.setAttribute('width',latchW);latchR.setAttribute('height',100);
            latchR.setAttribute('fill','#ccffcc');latchR.setAttribute('stroke','#666');
            svg.appendChild(latchR);
            const latchT = document.createElementNS(NS,'text');
            latchT.textContent='10mm L';
            latchT.setAttribute('x',x+latchW/2);latchT.setAttribute('y',16);
            latchT.setAttribute('text-anchor','middle');latchT.setAttribute('font-size','9');
            latchT.setAttribute('fill','#666');
            svg.appendChild(latchT);
            x += latchW;
            
          } else {
            // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
            
            // 10mm latch clearance
            const latchW = 10 * PX;
            const latchR = document.createElementNS(NS,'rect');
            latchR.setAttribute('x',x);latchR.setAttribute('y',20);
            latchR.setAttribute('width',latchW);latchR.setAttribute('height',100);
            latchR.setAttribute('fill','#ccffcc');latchR.setAttribute('stroke','#666');
            svg.appendChild(latchR);
            const latchT = document.createElementNS(NS,'text');
            latchT.textContent='10mm L';
            latchT.setAttribute('x',x+latchW/2);latchT.setAttribute('y',16);
            latchT.setAttribute('text-anchor','middle');latchT.setAttribute('font-size','9');
            latchT.setAttribute('fill','#666');
            svg.appendChild(latchT);
            x += latchW;

            // 890mm gate panel
            const gateW = 890 * PX;
            const gateR = document.createElementNS(NS,'rect');
            gateR.setAttribute('x',x);gateR.setAttribute('y',20);
            gateR.setAttribute('width',gateW);gateR.setAttribute('height',100);
            gateR.setAttribute('fill','#90EE90');gateR.setAttribute('stroke','#333');
            gateR.setAttribute('stroke-width','2');
            svg.appendChild(gateR);
            const gateT = document.createElementNS(NS,'text');
            gateT.textContent='890mm GATE';
            gateT.setAttribute('x',x+gateW/2);gateT.setAttribute('y',75);
            gateT.setAttribute('text-anchor','middle');gateT.setAttribute('font-size','14');
            gateT.setAttribute('font-weight','bold');
            gateT.setAttribute('fill','#006400');
            svg.appendChild(gateT);
            
            // Add latch graphic on the left side of gate
            const latchGraphic = document.createElementNS(NS,'rect');
            latchGraphic.setAttribute('x', x - 12);
            latchGraphic.setAttribute('y', 65);
            latchGraphic.setAttribute('width', 10);
            latchGraphic.setAttribute('height', 10);
            latchGraphic.setAttribute('fill', '#333');
            latchGraphic.setAttribute('stroke', '#000');
            latchGraphic.setAttribute('stroke-width', '2');
            svg.appendChild(latchGraphic);
            
            // Add hinge graphics on the right side of gate
            const hingeGraphic1 = document.createElementNS(NS,'rect');
            hingeGraphic1.setAttribute('x', x + gateW - 5);
            hingeGraphic1.setAttribute('y', 35);
            hingeGraphic1.setAttribute('width', 8);
            hingeGraphic1.setAttribute('height', 15);
            hingeGraphic1.setAttribute('fill', '#333');
            hingeGraphic1.setAttribute('stroke', '#000');
            hingeGraphic1.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic1);
            
            const hingeGraphic2 = document.createElementNS(NS,'rect');
            hingeGraphic2.setAttribute('x', x + gateW - 5);
            hingeGraphic2.setAttribute('y', 80);
            hingeGraphic2.setAttribute('width', 8);
            hingeGraphic2.setAttribute('height', 15);
            hingeGraphic2.setAttribute('fill', '#333');
            hingeGraphic2.setAttribute('stroke', '#000');
            hingeGraphic2.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic2);
            
            x += gateW;

            // 5mm hinge clearance
            const hingeW = 5 * PX;
            const hingeR = document.createElementNS(NS,'rect');
            hingeR.setAttribute('x',x);hingeR.setAttribute('y',20);
            hingeR.setAttribute('width',hingeW);hingeR.setAttribute('height',100);
            hingeR.setAttribute('fill','#ffcccc');hingeR.setAttribute('stroke','#666');
            svg.appendChild(hingeR);
            const hingeT = document.createElementNS(NS,'text');
            hingeT.textContent='5mm H';
            hingeT.setAttribute('x',x+hingeW/2);hingeT.setAttribute('y',16);
            hingeT.setAttribute('text-anchor','middle');hingeT.setAttribute('font-size','9');
            hingeT.setAttribute('fill','#666');
            svg.appendChild(hingeT);
            x += hingeW;
          }
        } else {
          // Regular gap
          const r2=document.createElementNS(NS,'rect');
          r2.setAttribute('x',x);r2.setAttribute('y',20);
          r2.setAttribute('width',gPx);r2.setAttribute('height',100);
          r2.setAttribute('fill','#ddd');
          svg.appendChild(r2);
          const t2=document.createElementNS(NS,'text');
          t2.textContent=rnd(lay.gap);
          t2.setAttribute('x',x+gPx/2);t2.setAttribute('y',16);
          t2.setAttribute('text-anchor','middle');t2.setAttribute('font-size','12');
          t2.setAttribute('font-weight','bold');
          t2.setAttribute('fill','#0077c8');
          svg.appendChild(t2);
          x+=gPx;
        }
      });

      wrap.querySelector('.view').appendChild(svg);
      
      // Add live gate position controls for sides with gates
      if (lay.gateSegment) {
        console.log(`Creating gate controls for side ${i}`);
        // Get current gate panel index (preserve existing position)
        let currentPanelIndex = lay.gateSegment.panelIndex;
        if (currentPanelIndex === undefined) {
          currentPanelIndex = Math.floor(lay.panelWidths.length / 2);
          lay.gateSegment.panelIndex = currentPanelIndex;
          lay.gateSegment.hingePanelIndex = lay.gateSegment.hingeOnLeft ? currentPanelIndex : currentPanelIndex + 1;
        }
        
        const totalPanels = lay.panelWidths.length;
        
        const gateControlsDiv = document.createElement('div');
        gateControlsDiv.style.cssText = 'margin-top:8px; padding:12px; background:linear-gradient(135deg, #f8fbff 0%, #e8f4ff 100%); border-radius:10px; border:1px solid #c5e1ff; box-shadow:0 2px 10px rgba(0,119,200,0.12);';
        gateControlsDiv.innerHTML = `
          <div style="display:flex; flex-direction:column; gap:0.5rem; align-items:flex-start;">
            <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
              <span style="font-size:0.9rem; color:#0066cc; font-weight:600; display:flex; align-items:center; gap:0.3rem;">🚪 Position:</span>
              <span class="liveGatePositionDisplay" data-side="${i}" style="font-size:0.8rem; color:#0066cc; text-align:center; font-weight:600; padding:0.3rem 0.6rem; background:#fff; border-radius:6px; border:1px solid #d4e6ff; box-shadow:0 1px 3px rgba(0,119,200,0.1);">Hinge: Panel ${currentPanelIndex}, Gate: Panel ${currentPanelIndex + 1}</span>
            </div>
            <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:nowrap; overflow-x:auto; width:100%; justify-content:flex-start;">
              <button type="button" class="liveGateFlip" data-side="${i}" onclick="flipGate(${i})" title="Flip Hinge-Gate Orientation"><span class="icon">🔄</span><span class="label">Flip Hinge-Gate Orientation</span></button>
              <button type="button" class="liveGateLeft" data-side="${i}" onclick="moveGate(${i}, 'left')" ${currentPanelIndex <= 0 ? 'disabled' : ''} title="Move Hinge-Gate Left"><span class="icon">←</span><span class="label">Move Hinge-Gate Left</span></button>
              <button type="button" class="liveGateRight" data-side="${i}" onclick="moveGate(${i}, 'right')" ${currentPanelIndex >= totalPanels - 2 ? 'disabled' : ''} title="Move Hinge-Gate Right"><span class="icon">→</span><span class="label">Move Hinge-Gate Right</span></button>
            </div>
          </div>
        `;
        wrap.appendChild(gateControlsDiv);
      }
    });
    
    /* ── 3. jump back to the same spot ────────────────────── */
    visual.scrollTop = savedTop;
    [...visual.querySelectorAll('.view')].forEach((v,i)=>{
      v.scrollLeft = savedLefts[i] ?? 0;
    });
    console.log(`Restored scroll positions: top=${savedTop}, restored ${savedLefts.length} view scroll positions`);
  }

  // Simple global functions for gate controls - SIMPLIFIED APPROACH
  function moveGate(sideIndex, direction) {
    console.log(`=== BUTTON CLICK DETECTED: moveGate called with side ${sideIndex}, direction ${direction} ===`);
    console.log(`=== moveGate called: side ${sideIndex}, direction ${direction} ===`);
    const layout = layouts[sideIndex];
    if (!layout || !layout.gateSegment) {
      console.log('ERROR: No layout or gate segment found!');
      return;
    }
    
    let currentPanelIndex = layout.gateSegment.panelIndex !== undefined ? layout.gateSegment.panelIndex : Math.floor(layout.panelWidths.length / 2);
    let hi = layout.gateSegment.hingeOnLeft ? currentPanelIndex : currentPanelIndex + 1;   // hinge panel's slot
    const totalPanels = layout.panelWidths.length;
    
    console.log(`BEFORE: Gate at panel ${currentPanelIndex}, Hinge at slot ${hi}, Total panels: ${totalPanels}`);
    console.log(`BEFORE: Panel widths:`, layout.panelWidths);
    console.log(`BEFORE: hingeOnLeft = ${layout.gateSegment.hingeOnLeft}`);
    
    // Save the original hinge index for debugging
    const originalHi = hi;
    
    // Unrestricted movement - gate can go anywhere from 0 to N-1
    const hingeOnLeft = layout.gateSegment.hingeOnLeft !== undefined ? layout.gateSegment.hingeOnLeft : false;
    
    console.log(`BEFORE MOVEMENT: Gate at panel ${currentPanelIndex}, hingeOnLeft=${hingeOnLeft}`);
    console.log(`BEFORE MOVEMENT: Array length=${layout.panelWidths.length}`);
    
    // Calculate new position (SINGLE calculation only)
    let newPanelIndex = currentPanelIndex;
    
    // Calculate movement boundaries - allow movement as long as final positions are valid
    // After movement, we need both gate and hinge to fit in the array
    let canMoveLeft = false;
    let canMoveRight = false;
    
    if (direction === 'left' && currentPanelIndex > 0) {
      const testGatePos = currentPanelIndex - 1;
      const testHingePos = hingeOnLeft ? testGatePos : testGatePos + 1;
      // Can move left if both positions are valid (>= 0)
      canMoveLeft = testGatePos >= 0 && testHingePos >= 0;
    }
    
    if (direction === 'right' && currentPanelIndex < totalPanels - 1) {
      const testGatePos = currentPanelIndex + 1;
      const testHingePos = hingeOnLeft ? testGatePos : testGatePos + 1;
      // Can move right if both positions are valid (< totalPanels)
      canMoveRight = testGatePos < totalPanels && testHingePos < totalPanels;
    }
    
    console.log(`Movement check: left=${canMoveLeft}, right=${canMoveRight}, current=${currentPanelIndex}`);
    
    if (direction === 'left' && canMoveLeft) {
      newPanelIndex = currentPanelIndex - 1;
      console.log(`LEFT movement: ${currentPanelIndex} -> ${newPanelIndex}`);
    } else if (direction === 'right' && canMoveRight) {
      newPanelIndex = currentPanelIndex + 1;
      console.log(`RIGHT movement: ${currentPanelIndex} -> ${newPanelIndex}`);
    } else {
      console.log(`Cannot move gate further ${direction} - would exceed bounds`);
      return;
    }
    
    // SIMPLE ARRAY MANIPULATION: Move hinge panel to follow gate
    const oldHingeIndex = layout.gateSegment.hingePanelIndex;
    const targetHingeIndex = hingeOnLeft ? newPanelIndex : newPanelIndex + 1;
    
    console.log(`TARGET POSITIONS: Gate=${newPanelIndex}, Hinge=${targetHingeIndex}`);
    console.log(`CURRENT POSITIONS: Gate=${currentPanelIndex}, Hinge=${oldHingeIndex}`);
    
    // Only move if the hinge position actually changed
    if (oldHingeIndex !== undefined && oldHingeIndex !== targetHingeIndex) {
      // Remove hinge panel from old position
      const hingeWidth = layout.panelWidths.splice(oldHingeIndex, 1)[0];
      console.log(`Removed hinge panel width ${hingeWidth} from position ${oldHingeIndex}`);
      
      // Adjust target positions based on removal
      let finalGateIndex = newPanelIndex;
      let finalHingeIndex = targetHingeIndex;
      
      if (oldHingeIndex < newPanelIndex) {
        // Hinge was before gate, so gate position shifts down
        finalGateIndex = newPanelIndex - 1;
        finalHingeIndex = hingeOnLeft ? finalGateIndex : finalGateIndex + 1;
        console.log(`Adjusted positions due to hinge removal: Gate=${finalGateIndex}, Hinge=${finalHingeIndex}`);
      }
      
      // Insert hinge panel at new position
      layout.panelWidths.splice(finalHingeIndex, 0, hingeWidth);
      console.log(`Inserted hinge panel at position ${finalHingeIndex}`);
      
      // Update tracking with final positions
      layout.gateSegment.panelIndex = finalGateIndex;
      layout.gateSegment.hingePanelIndex = finalHingeIndex;
      
      console.log(`FINAL POSITIONS: Gate=${layout.gateSegment.panelIndex}, Hinge=${layout.gateSegment.hingePanelIndex}`);
    } else {
      // No hinge movement needed, just update gate position
      layout.gateSegment.panelIndex = newPanelIndex;
      console.log(`No hinge movement needed. Gate position: ${newPanelIndex}`);
    }
    
    // Redraw everything (drawRows will preserve scroll position automatically)
    drawRows();
    
    console.log('=== moveGate completed ===');
  }

  function flipGate(sideIndex) {
    console.log(`=== BUTTON CLICK DETECTED: flipGate called with side ${sideIndex} ===`);
    console.log(`flipGate called: side ${sideIndex}`);
    const layout = layouts[sideIndex];
    if (!layout || !layout.gateSegment) return;
    
    const gi = layout.gateSegment.panelIndex;
    const oldHi = layout.gateSegment.hingeOnLeft ? gi : gi + 1;
    const hingeWidth = layout.panelWidths.splice(oldHi, 1)[0];
    
    // Toggle hinge orientation
    layout.gateSegment.hingeOnLeft = !layout.gateSegment.hingeOnLeft;
    console.log(`Flipped gate orientation: hingeOnLeft = ${layout.gateSegment.hingeOnLeft}`);
    
    const newHi = layout.gateSegment.hingeOnLeft ? gi : gi + 1;
    layout.panelWidths.splice(newHi, 0, hingeWidth);
    
    // Update hinge panel index tracking
    layout.gateSegment.hingePanelIndex = newHi;
    
    // Redraw everything (drawRows will preserve scroll position automatically)
    drawRows();
  }

  // ─── Full‐plan SVG, PNG & PDF ──────────────────────────────
  function buildPlanSVG(layouts,runs){
    const NS='http://www.w3.org/2000/svg',BAR=15,GAPF=8,PANF=10;
    
    // Use custom shape data if available, otherwise default to orthogonal directions
    const useCustomDirections = window.customShapeData && window.customShapeData.isCustom;
    let pts=[[0,0]],x=0,y=0;
    
    if (useCustomDirections) {
      // Use actual direction vectors from custom shape
      const customRuns = window.customShapeData.runs;
      const scale = 0.001; // Convert mm to plan units
      customRuns.forEach((run, i) => {
        x += run.dx * scale;
        y += run.dy * scale;
        pts.push([x, y]);
      });
    } else {
      // Use default orthogonal directions for standard shapes
      const dirs=[[1,0],[0,1],[-1,0],[0,-1]];
      runs.forEach((l,i)=>{ x+=dirs[i%4][0]*l; y+=dirs[i%4][1]*l; pts.push([x,y]); });
    }
    
    const minX=Math.min(...pts.map(p=>p[0])),minY=Math.min(...pts.map(p=>p[1]));
    pts=pts.map(([px,py])=>[(px-minX)*PX+MAR,(py-minY)*PX+MAR]);
    const W=Math.max(...pts.map(p=>p[0]))+MAR,H=Math.max(...pts.map(p=>p[1]))+MAR;
    const svg=document.createElementNS(NS,'svg');
    svg.setAttribute('xmlns',NS);
    svg.setAttribute('width',W);
    svg.setAttribute('height',H);
    svg.setAttribute('fill','none');
    const poly=document.createElementNS(NS,'polyline');
    poly.setAttribute('points',pts.map(p=>p.join(',')).join(' '));
    poly.setAttribute('stroke','#000');
    poly.setAttribute('stroke-width','2');
    svg.appendChild(poly);

    let cx=pts[0][0],cy=pts[0][1];
    layouts.forEach((lay,i)=>{
      // Calculate direction for this segment
      let dx, dy;
      if (useCustomDirections && window.customShapeData.runs[i]) {
        const run = window.customShapeData.runs[i];
        const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
        dx = run.dx / length; // Normalize to unit vector
        dy = run.dy / length;
      } else {
        // Use default orthogonal directions
        const dirs=[[1,0],[0,1],[-1,0],[0,-1]];
        [dx,dy] = dirs[i%4];
      }
      
      // Debug: Check if this side's layout matches expectations
      if (i === 2) { // Side C debug
        console.log(`PLAN VIEW Side C: dx=${dx}, dy=${dy}, panels=[${lay.panelWidths.join(', ')}]`);
        console.log(`Side C layout object:`, lay);
      }
      
function seg(mm,col,lab,isP){
  const len=mm*PX,w=dx?len:BAR,h=dy?len:BAR,rx=dx<0?-w:0,ry=dy<0?-h:0;
  const r=document.createElementNS(NS,'rect');
  r.setAttribute('x',cx+rx);r.setAttribute('y',cy+ry);
  r.setAttribute('width',w);r.setAttribute('height',h);r.setAttribute('fill',col);
  if(isP) r.setAttribute('stroke','#333');
  svg.appendChild(r);

  // Panel label - REMOVED to avoid duplication (handled in panelWidths.forEach)
  // if(isP){
  //   Panel measurements now handled in the panelWidths.forEach loop
  // }
  
  if(!isP) {
    // Gap label - positioned on OUTSIDE of fence perimeter (except corners)
    const t=document.createElementNS(NS,'text');
    t.textContent = `${lab}`;
    t.setAttribute('font-size', '18');
    t.setAttribute('font-weight', 'bold');
    t.setAttribute('fill', '#0077c8');
    t.setAttribute('text-anchor','middle');
    t.setAttribute('dominant-baseline','middle');
    
    // Check if this is a corner gap - simpler approach based on side transitions
    // Corner gaps occur at the start of each side (except first side which we skip)
    const isCornerGap = (i > 0); // All sides after the first start at a corner
    
    if(dx){
      // Horizontal gap - position based on direction
      if (dx > 0) {
        // Moving right (Side A) - put gap text ABOVE fence line (outside)
        t.setAttribute('x',cx+rx+w/2); 
        t.setAttribute('y',cy+ry-15);
      } else {
        // Moving left (Side C) - put gap text BELOW fence line (outside)
        t.setAttribute('x',cx+rx+w/2); 
        t.setAttribute('y',cy+ry+h+25);
      }
    }else{
      // Vertical gap - position based on direction
      if (dy > 0) {
        // Moving down (Side B) - put gap text to RIGHT of fence line (outside)
        t.setAttribute('x',cx+rx+w+25);
        t.setAttribute('y',cy+ry+h/2);
        t.setAttribute('transform', `rotate(90 ${cx+rx+w+25} ${cy+ry+h/2})`);
      } else {
        // Moving up (Side D) - put gap text to LEFT of fence line (outside)
        t.setAttribute('x',cx+rx-25);
        t.setAttribute('y',cy+ry+h/2);
        t.setAttribute('transform', `rotate(90 ${cx+rx-25} ${cy+ry+h/2})`);
      }
    }
    svg.appendChild(t);
  }
  cx+=dx*len;cy+=dy*len;
}
      // Determine if this side should have start/end gaps based on shape configuration
      // Gaps appear between fence sections, but not at overlap points where sides connect
      let hasStartGap = true;
      let hasEndGap = true;
      
      if (curShape) {
        if (curShape.id === 'U') {
          // U shape (3 sides): A(top)-B(right)-C(bottom)
          if (i === 0) {
            // Side A (top): Start gap ✓, End gap ✓ (between connections to B)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 1) {
            // Side B (right): No start gap, No end gap (overlaps with A and C)
            hasStartGap = false;
            hasEndGap = false;
          } else if (i === 2) {
            // Side C (bottom): Start gap ✓, End gap ✓ (between connections to B)
            hasStartGap = true;
            hasEndGap = true;
          }
        } else if (curShape.id === 'BOX') {
          // BOX shape (4 sides): A(top)-B(right)-C(bottom)-D(left)
          if (i === 0) {
            // Side A (top): Start gap ✓, End gap ✓ (between connections to B & D)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 1) {
            // Side B (right): No start gap, No end gap (overlaps with A and C)
            hasStartGap = false;
            hasEndGap = false;
          } else if (i === 2) {
            // Side C (bottom): Start gap ✓, End gap ✓ (between connections to B & D)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 3) {
            // Side D (left): No start gap, No end gap (overlaps with A and C)
            hasStartGap = false;
            hasEndGap = false;
          }
        } else if (curShape.id === 'L') {
          // L shape (2 sides): A(top)-B(right)
          if (i === 0) {
            // Side A (top): Start gap ✓, End gap ✓ (between connections to B)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 1) {
            // Side B (right): No start gap (overlaps A), End gap ✓
            hasStartGap = false;
            hasEndGap = true;
          }
        }
        // INLINE shape: single side, has both start and end gaps (default)
      }
      
      // For Side C (moving left) and Side D (moving up), reverse the panel order to match elevation view display
      let panelsToProcess = lay.panelWidths;
      if (i === 2 && dx < 0) { // Side C moving left
        panelsToProcess = [...lay.panelWidths].reverse();
        console.log(`Side C panels reversed: [${panelsToProcess.join(', ')}]`);
      } else if (i === 3 && dy < 0) { // Side D moving up
        panelsToProcess = [...lay.panelWidths].reverse();
        console.log(`Side D panels reversed: [${panelsToProcess.join(', ')}]`);
      }

      // Draw initial gap only for sides that should have one
      if(hasStartGap) {
        if (i === 2) { // Side C - make gap white to show overlap clearly
          seg(lay.gap,'#ffffff','',false);
        } else {
          seg(lay.gap,'#ddd',rnd(lay.gap),false);
        }
      }
panelsToProcess.forEach((pw, panelIndex) => {
  // Save current position before drawing
  const prevCx = cx, prevCy = cy;

  // Draw panel
  seg(pw,'#a8d6ff',pw,true);

  // Calculate panel center for label
  const panelLen = pw * PX;
  let panelCenterX, panelCenterY;
  
  if (dx) {
    // Horizontal movement
    if (dx > 0) {
      // Moving right - panel extends from prevCx to prevCx + panelLen
      panelCenterX = prevCx + panelLen / 2;
    } else {
      // Moving left - panel extends from prevCx - panelLen to prevCx
      panelCenterX = prevCx - panelLen / 2;
    }
    panelCenterY = prevCy;
  } else {
    // Vertical movement
    panelCenterX = prevCx;
    if (dy > 0) {
      // Moving down - panel extends from prevCy to prevCy + panelLen
      panelCenterY = prevCy + panelLen / 2;
    } else {
      // Moving up - panel extends from prevCy - panelLen to prevCy
      panelCenterY = prevCy - panelLen / 2;
    }
  }

  // Add panel measurement label
const t = document.createElementNS(NS,'text');
t.textContent = `${pw} mm`;
t.setAttribute('font-size', '25');           // Larger
t.setAttribute('font-weight', 'bold');        // Bold
t.setAttribute('fill', '#111');               // Black
  if (dx) {
    // Horizontal panel - position measurement based on direction
    t.setAttribute('x', panelCenterX);
    if (dx > 0) {
      // Moving right (Side A) - put text BELOW panel (inside)
      t.setAttribute('y', prevCy + 35); 
    } else {
      // Moving left (Side C) - put text ABOVE panel (inside)  
      t.setAttribute('y', prevCy - 10);
    }
    t.setAttribute('text-anchor', 'middle');
  } else {
    // Vertical panel - position measurement based on direction
    if (dy > 0) {
      // Moving down (Side B) - put text to LEFT of panel (inside)
      t.setAttribute('x', prevCx - 25);
      t.setAttribute('y', panelCenterY);
      t.setAttribute('dominant-baseline', 'middle');
      t.setAttribute('transform', `rotate(90 ${prevCx - 25} ${panelCenterY})`);
    } else {
      // Moving up (Side D) - put text to RIGHT of panel (inside)
      t.setAttribute('x', prevCx + BAR + 25);
      t.setAttribute('y', panelCenterY);
      t.setAttribute('dominant-baseline', 'middle');
      t.setAttribute('transform', `rotate(90 ${prevCx + BAR + 25} ${panelCenterY})`);
    }
  }
  svg.appendChild(t);

  // Check if this panel is where the gate should be placed
  let gatePanelIndex = null;
  if (lay.gateSegment) {
    // Use panelIndex for precise gate positioning, fallback to position-based for legacy
    if (lay.gateSegment.panelIndex !== undefined) {
      gatePanelIndex = lay.gateSegment.panelIndex;
    } else {
      const totalPanels = lay.panelWidths.length;
      const position = lay.gateSegment.position || 'middle';
      
      // Calculate gate panel index based on position (legacy support)
      if (position === 'left') {
        gatePanelIndex = Math.floor(totalPanels * 0.25); // 25% from left
      } else if (position === 'right') {
        gatePanelIndex = Math.floor(totalPanels * 0.75); // 75% from left  
      } else { // middle
        gatePanelIndex = Math.floor(totalPanels / 2); // 50% from left
      }
    }
  }
  
  if (lay.gateSegment && panelIndex === gatePanelIndex) {
    // Draw gate elements with dynamic orientation based on hingeOnLeft
    const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
    
    if (hingeOnLeft) {
      // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
      seg(5,'#ffcccc','5mm H',false);
      seg(890,'#90EE90','GATE',true);
      seg(10,'#ccffcc','10mm L',false);
    } else {
      // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
      seg(10,'#ccffcc','10mm L',false);
      seg(890,'#90EE90','GATE',true);
      seg(5,'#ffcccc','5mm H',false);
    }
  } else {
    // Draw regular gap after panel, but only if this isn't the last panel of a side that shouldn't have end gaps
    const isLastPanel = (panelIndex === lay.panelWidths.length - 1);
    const shouldDrawGap = !isLastPanel || hasEndGap;
    
    if (shouldDrawGap) {
      seg(lay.gap,'#ddd',rnd(lay.gap),false);
    }
  }
});

// Draw gap at the end of each side only if it should have one
if(hasEndGap) {
  if (i === 2) { // Side C - make gap white to show overlap clearly
    seg(lay.gap,'#ffffff','',false);
  } else {
    seg(lay.gap,'#ddd',rnd(lay.gap),false);
  }
}
    });

    const defs=document.createElementNS(NS,'defs');
    defs.innerHTML=`<marker id="arr" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto" markerUnits="strokeWidth"><path d="M0 0 L10 5 L0 10 Z" fill="#ff0000"/></marker>`;
    svg.appendChild(defs);

    function arrow(x1,y1,x2,y2,txt,vert,direction){
      const l=document.createElementNS(NS,'line');
      l.setAttribute('x1',x1);l.setAttribute('y1',y1);
      l.setAttribute('x2',x2);l.setAttribute('y2',y2);
      l.setAttribute('stroke','#ff0000');  // Make red for visibility
      l.setAttribute('stroke-width','4');   // Much thicker lines
      l.setAttribute('marker-start','url(#arr)');
      l.setAttribute('marker-end','url(#arr)');
      svg.appendChild(l);
      
      const t=document.createElementNS(NS,'text');
      t.textContent=`${txt} mm`;
      t.setAttribute('font-size', '22');    // Even bigger font for readability
      t.setAttribute('font-weight','bold');
      t.setAttribute('fill','#ff0000');     // Red text to match arrow
      t.setAttribute('text-anchor','middle');
      t.setAttribute('dominant-baseline','middle');
      
      if(vert){
        // For vertical arrows, position text on the OUTSIDE
        if(direction === 'right') {
          // Arrow is to the right of fence, put text further right
          t.setAttribute('x', x1 + 30);
          t.setAttribute('y', (y1+y2)/2);
          t.setAttribute('transform',`rotate(90 ${x1+30} ${(y1+y2)/2})`);  // Changed to +90
        } else {
          // Arrow is to the left of fence, put text further left
          t.setAttribute('x', x1 - 30);
          t.setAttribute('y', (y1+y2)/2);
          t.setAttribute('transform',`rotate(90 ${x1-30} ${(y1+y2)/2})`);  // Changed to +90
        }
      } else {
        // For horizontal arrows, position text on the OUTSIDE
        if(direction === 'above') {
          // Arrow is above fence, put text further above
          t.setAttribute('x',(x1+x2)/2);
          t.setAttribute('y',y1-25);
        } else {
          // Arrow is below fence, put text further below
          t.setAttribute('x',(x1+x2)/2);
          t.setAttribute('y',y1+35);
        }
      }
      svg.appendChild(t);
    }

const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

for (let i = 0; i < runs.length; i++) {
  const pStart = pts[i];
  const pEnd = pts[i + 1];
  if (!pStart || !pEnd) continue;
  
  // Calculate direction of this side
  const dx = pEnd[0] - pStart[0];
  const dy = pEnd[1] - pStart[1];
  const isHorizontal = Math.abs(dx) > Math.abs(dy);
  const offset = 80;  // Increased offset for more space
  
  let x1, y1, x2, y2, direction;
  
  if (isHorizontal) {
    // Horizontal side - put arrow above or below
    if (dx > 0) {
      // Moving right - put arrow above
      x1 = pStart[0];
      x2 = pEnd[0];
      y1 = y2 = pStart[1] - offset;
      direction = 'above';
    } else {
      // Moving left - put arrow below, but reverse direction for correct arrowheads
      x1 = pEnd[0];
      x2 = pStart[0];
      y1 = y2 = pStart[1] + offset;
      direction = 'below';
    }
  } else {
    // Vertical side - put arrow left or right
    if (dy > 0) {
      // Moving down - put arrow to the right
      y1 = pStart[1];
      y2 = pEnd[1];
      x1 = x2 = pStart[0] + offset;
      direction = 'right';
    } else {
      // Moving up - put arrow to the left, but reverse direction for correct arrowheads
      y1 = pEnd[1];
      y2 = pStart[1];
      x1 = x2 = pStart[0] - offset;
      direction = 'left';
    }
  }
  
  // Draw arrow with measurement, passing direction info
  arrow(x1, y1, x2, y2, `${letters[i]}: ${runs[i]}`, !isHorizontal, direction);
}

// Add overall run length label at the top left
const totalRun = runs.reduce((a, b) => a + b, 0);
const overallLabel = document.createElementNS(NS, 'text');
overallLabel.setAttribute('x', W/2);
overallLabel.setAttribute('y', 20); // slightly higher
overallLabel.setAttribute('text-anchor', 'middle');
overallLabel.setAttribute('font-size', '16');
overallLabel.setAttribute('font-weight', '700');
overallLabel.setAttribute('fill', '#0077c8');
svg.appendChild(overallLabel);

    return svg;
  }

  // ─── Custom Shape Plan SVG for accurate PDF generation ──────────────────────────
  function buildCustomPlanSVG(layouts, customRuns) {
    const NS='http://www.w3.org/2000/svg',BAR=15,GAPF=8,PANF=10,MAR=50,PX=0.1;
    
    // Constants for professional styling
    const INSET = 6; // Distance from red outline to blue panels
    const LABEL_OFFSET = 3; // Extra gap for blue/grey text beyond red arrows
    const PANEL_THICKNESS = 8;
    const PANEL_FONT = 10; // Larger font for better readability
    const GAP_FONT = 9; // Larger gap font for better readability
    
    // Build fence outline points using actual direction vectors
    let pts=[[0,0]],x=0,y=0;
    
    customRuns.forEach((run, i) => {
      x += run.dx * PX;
      y += run.dy * PX;
      pts.push([x, y]);
    });
    
    // Normalize to positive coordinates and add margins
    const minX=Math.min(...pts.map(p=>p[0])),minY=Math.min(...pts.map(p=>p[1]));
    pts=pts.map(([px,py])=>[(px-minX)+MAR,(py-minY)+MAR]);
    const W=Math.max(...pts.map(p=>p[0]))+MAR,H=Math.max(...pts.map(p=>p[1]))+MAR;
    
    // Create SVG
    const svg=document.createElementNS(NS,'svg');
    svg.setAttribute('xmlns',NS);
    svg.setAttribute('width',W);
    svg.setAttribute('height',H);
    svg.setAttribute('fill','none');

    // Add arrow markers first
    const defs = document.createElementNS(NS, 'defs');
    const marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id', 'arrowhead');
    marker.setAttribute('markerWidth', '10');
    marker.setAttribute('markerHeight', '7');
    marker.setAttribute('refX', '9');
    marker.setAttribute('refY', '3.5');
    marker.setAttribute('orient', 'auto');
    
    const polygon = document.createElementNS(NS, 'polygon');
    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
    polygon.setAttribute('fill', '#d32f2f');
    marker.appendChild(polygon);
    defs.appendChild(marker);
    svg.appendChild(defs);

    // LAYER 1: Red outline + arrows (background)
    customRuns.forEach((run, i) => {
      if (!pts[i] || !pts[i + 1]) return;
      
      // Calculate outward normal for this side to offset arrows outside panels
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const normalX = -run.dy / length;
      const normalY = run.dx / length;
      
      // Offset arrow points well outside the panel area with extra clearance
      const extraOffset = INSET + PANEL_THICKNESS + 12; // Panel thickness + generous clearance
      const offsetStartX = pts[i][0] + normalX * extraOffset;
      const offsetStartY = pts[i][1] + normalY * extraOffset;
      const offsetEndX = pts[i + 1][0] + normalX * extraOffset;
      const offsetEndY = pts[i + 1][1] + normalY * extraOffset;
      
      // Arrow line (positioned outside panels)
      const arrowLine = document.createElementNS(NS,'line');
      arrowLine.setAttribute('x1', offsetStartX);
      arrowLine.setAttribute('y1', offsetStartY);
      arrowLine.setAttribute('x2', offsetEndX);
      arrowLine.setAttribute('y2', offsetEndY);
      arrowLine.setAttribute('stroke', '#d32f2f');
      arrowLine.setAttribute('stroke-width', '2');
      arrowLine.setAttribute('marker-end', 'url(#arrowhead)');
      arrowLine.setAttribute('marker-start', 'url(#arrowhead)');
      svg.appendChild(arrowLine);
      
      // Side length label (positioned away from blue panels)
      const midX = (offsetStartX + offsetEndX) / 2;
      const midY = (offsetStartY + offsetEndY) / 2;
      const dx = offsetEndX - offsetStartX;
      const dy = offsetEndY - offsetStartY;
      const dirLength = Math.sqrt(dx*dx + dy*dy);
      const labelNormalX = -dy / dirLength;
      const labelNormalY = dx / dirLength;
      const labelOffset = 15; // Reduced offset to keep text closer to arrow line
      
      const labelX = midX + labelNormalX * labelOffset;
      const labelY = midY + labelNormalY * labelOffset;
      
      const text = document.createElementNS(NS,'text');
      text.textContent = `${run.id}: ${Math.round(run.length)} mm`;
      text.setAttribute('x', labelX);
      text.setAttribute('y', labelY);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-size', '14');
      text.setAttribute('font-weight', 'bold');
      text.setAttribute('fill', '#d32f2f');
      
      // Keep text upright: flip if it would be upside-down (more aggressive flipping)
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      const normalizedAngle = (angle + 360) % 360;
      const finalAngle = (normalizedAngle > 80 && normalizedAngle < 280) ? angle + 180 : angle;
      
      text.setAttribute('transform', `rotate(${finalAngle} ${labelX} ${labelY})`);
      svg.appendChild(text);
    });

    // LAYER 2: Blue panels (middle layer)
    layouts.forEach((lay,i)=>{
      const run = customRuns[i];
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const unitDx = run.dx / length;
      const unitDy = run.dy / length;
      
      // Calculate inset start position for this side's panels
      let currentX = 0, currentY = 0;
      for (let j = 0; j < i; j++) {
        currentX += customRuns[j].dx * PX;
        currentY += customRuns[j].dy * PX;
      }
      
      // Apply inset to move panels inside the outline
      const normalX = -unitDy;
      const normalY = unitDx;
      const insetX = normalX * INSET;
      const insetY = normalY * INSET;
      
      const startX = (currentX - minX) + MAR + insetX;
      const startY = (currentY - minY) + MAR + insetY;
      
      let sideProgress = 0;
      
      // Gate detection logic (same as 3D rendering)
      let gatePanelIndex = null;
      if (lay.gateSegment) {
        if (lay.gateSegment.panelIndex !== undefined) {
          gatePanelIndex = lay.gateSegment.panelIndex;
        } else {
          const totalPanels = lay.panelWidths.length;
          const position = lay.gateSegment.position || 'middle';
          if (position === 'left') {
            gatePanelIndex = Math.floor(totalPanels * 0.25);
          } else if (position === 'right') {
            gatePanelIndex = Math.floor(totalPanels * 0.75);
          } else {
            gatePanelIndex = Math.floor(totalPanels / 2);
          }
        }
      }
      
      lay.panelWidths.forEach((pw, panelIndex) => {
        const panelLen = pw * PX;
        
        const panelStartX = startX + sideProgress * unitDx;
        const panelStartY = startY + sideProgress * unitDy;
        const panelCenterX = panelStartX + (panelLen / 2) * unitDx;
        const panelCenterY = panelStartY + (panelLen / 2) * unitDy;
        
        // Create rotated rectangle for the panel
        const angle = Math.atan2(unitDy, unitDx) * 180 / Math.PI;
        const halfLen = panelLen / 2;
        const halfThick = PANEL_THICKNESS / 2;
        
        const corners = [
          [-halfLen, -halfThick], [halfLen, -halfThick], 
          [halfLen, halfThick], [-halfLen, halfThick]
        ];
        
        const rotatedCorners = corners.map(([x, y]) => {
          const cos = Math.cos(angle * Math.PI / 180);
          const sin = Math.sin(angle * Math.PI / 180);
          return [
            panelCenterX + (x * cos - y * sin),
            panelCenterY + (x * sin + y * cos)
          ];
        });
        
        // Blue panel
        const panel = document.createElementNS(NS,'polygon');
        panel.setAttribute('points', rotatedCorners.map(p => p.join(',')).join(' '));
        panel.setAttribute('fill', 'rgba(190,220,255,1)');
        panel.setAttribute('stroke', 'rgb(50,100,180)');
        panel.setAttribute('stroke-width', '0.25');
        svg.appendChild(panel);

        sideProgress += panelLen;
        
        // Gate handling: add gate segments instead of normal gap
        if (lay.gateSegment && panelIndex === gatePanelIndex && panelIndex < lay.panelWidths.length - 1) {
          const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
          
          if (hingeOnLeft) {
            // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
            // 5mm hinge (light red)
            const hingeLen = 5 * PX;
            const hingeStartX = startX + sideProgress * unitDx;
            const hingeStartY = startY + sideProgress * unitDy;
            const hingeCenterX = hingeStartX + (hingeLen / 2) * unitDx;
            const hingeCenterY = hingeStartY + (hingeLen / 2) * unitDy;
            
            const hingeCorners = [
              [-hingeLen/2, -halfThick], [hingeLen/2, -halfThick], 
              [hingeLen/2, halfThick], [-hingeLen/2, halfThick]
            ];
            
            const hingeRotatedCorners = hingeCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                hingeCenterX + (x * cos - y * sin),
                hingeCenterY + (x * sin + y * cos)
              ];
            });
            
            const hingePanel = document.createElementNS(NS,'polygon');
            hingePanel.setAttribute('points', hingeRotatedCorners.map(p => p.join(',')).join(' '));
            hingePanel.setAttribute('fill', '#ffcccc');
            hingePanel.setAttribute('stroke', '#cc9999');
            hingePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(hingePanel);
            
            sideProgress += hingeLen;
            
            // 890mm gate (green)
            const gateLen = 890 * PX;
            const gateStartX = startX + sideProgress * unitDx;
            const gateStartY = startY + sideProgress * unitDy;
            const gateCenterX = gateStartX + (gateLen / 2) * unitDx;
            const gateCenterY = gateStartY + (gateLen / 2) * unitDy;
            
            const gateCorners = [
              [-gateLen/2, -halfThick], [gateLen/2, -halfThick], 
              [gateLen/2, halfThick], [-gateLen/2, halfThick]
            ];
            
            const gateRotatedCorners = gateCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                gateCenterX + (x * cos - y * sin),
                gateCenterY + (x * sin + y * cos)
              ];
            });
            
            const gatePanel = document.createElementNS(NS,'polygon');
            gatePanel.setAttribute('points', gateRotatedCorners.map(p => p.join(',')).join(' '));
            gatePanel.setAttribute('fill', '#90EE90');
            gatePanel.setAttribute('stroke', '#4CAF50');
            gatePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(gatePanel);
            
            sideProgress += gateLen;
            
            // 10mm latch (light green)
            const latchLen = 10 * PX;
            const latchStartX = startX + sideProgress * unitDx;
            const latchStartY = startY + sideProgress * unitDy;
            const latchCenterX = latchStartX + (latchLen / 2) * unitDx;
            const latchCenterY = latchStartY + (latchLen / 2) * unitDy;
            
            const latchCorners = [
              [-latchLen/2, -halfThick], [latchLen/2, -halfThick], 
              [latchLen/2, halfThick], [-latchLen/2, halfThick]
            ];
            
            const latchRotatedCorners = latchCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                latchCenterX + (x * cos - y * sin),
                latchCenterY + (x * sin + y * cos)
              ];
            });
            
            const latchPanel = document.createElementNS(NS,'polygon');
            latchPanel.setAttribute('points', latchRotatedCorners.map(p => p.join(',')).join(' '));
            latchPanel.setAttribute('fill', '#ccffcc');
            latchPanel.setAttribute('stroke', '#99cc99');
            latchPanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(latchPanel);
            
            sideProgress += latchLen;
          } else {
            // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
            // 10mm latch (light green)
            const latchLen = 10 * PX;
            const latchStartX = startX + sideProgress * unitDx;
            const latchStartY = startY + sideProgress * unitDy;
            const latchCenterX = latchStartX + (latchLen / 2) * unitDx;
            const latchCenterY = latchStartY + (latchLen / 2) * unitDy;
            
            const latchCorners = [
              [-latchLen/2, -halfThick], [latchLen/2, -halfThick], 
              [latchLen/2, halfThick], [-latchLen/2, halfThick]
            ];
            
            const latchRotatedCorners = latchCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                latchCenterX + (x * cos - y * sin),
                latchCenterY + (x * sin + y * cos)
              ];
            });
            
            const latchPanel = document.createElementNS(NS,'polygon');
            latchPanel.setAttribute('points', latchRotatedCorners.map(p => p.join(',')).join(' '));
            latchPanel.setAttribute('fill', '#ccffcc');
            latchPanel.setAttribute('stroke', '#99cc99');
            latchPanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(latchPanel);
            
            sideProgress += latchLen;
            
            // 890mm gate (green)
            const gateLen = 890 * PX;
            const gateStartX = startX + sideProgress * unitDx;
            const gateStartY = startY + sideProgress * unitDy;
            const gateCenterX = gateStartX + (gateLen / 2) * unitDx;
            const gateCenterY = gateStartY + (gateLen / 2) * unitDy;
            
            const gateCorners = [
              [-gateLen/2, -halfThick], [gateLen/2, -halfThick], 
              [gateLen/2, halfThick], [-gateLen/2, halfThick]
            ];
            
            const gateRotatedCorners = gateCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                gateCenterX + (x * cos - y * sin),
                gateCenterY + (x * sin + y * cos)
              ];
            });
            
            const gatePanel = document.createElementNS(NS,'polygon');
            gatePanel.setAttribute('points', gateRotatedCorners.map(p => p.join(',')).join(' '));
            gatePanel.setAttribute('fill', '#90EE90');
            gatePanel.setAttribute('stroke', '#4CAF50');
            gatePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(gatePanel);
            
            sideProgress += gateLen;
            
            // 5mm hinge (light red)
            const hingeLen = 5 * PX;
            const hingeStartX = startX + sideProgress * unitDx;
            const hingeStartY = startY + sideProgress * unitDy;
            const hingeCenterX = hingeStartX + (hingeLen / 2) * unitDx;
            const hingeCenterY = hingeStartY + (hingeLen / 2) * unitDy;
            
            const hingeCorners = [
              [-hingeLen/2, -halfThick], [hingeLen/2, -halfThick], 
              [hingeLen/2, halfThick], [-hingeLen/2, halfThick]
            ];
            
            const hingeRotatedCorners = hingeCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                hingeCenterX + (x * cos - y * sin),
                hingeCenterY + (x * sin + y * cos)
              ];
            });
            
            const hingePanel = document.createElementNS(NS,'polygon');
            hingePanel.setAttribute('points', hingeRotatedCorners.map(p => p.join(',')).join(' '));
            hingePanel.setAttribute('fill', '#ffcccc');
            hingePanel.setAttribute('stroke', '#cc9999');
            hingePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(hingePanel);
            
            sideProgress += hingeLen;
          }
        } else if (panelIndex < lay.panelWidths.length - 1) {
          // Add normal gap space only if no gate
          sideProgress += lay.gap * PX;
        }
      });
    });

    // LAYER 3: Blue panel length labels (on top of red lines)
    layouts.forEach((lay,i)=>{
      const run = customRuns[i];
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const unitDx = run.dx / length;
      const unitDy = run.dy / length;
      
      let currentX = 0, currentY = 0;
      for (let j = 0; j < i; j++) {
        currentX += customRuns[j].dx * PX;
        currentY += customRuns[j].dy * PX;
      }
      
      const normalX = -unitDy;
      const normalY = unitDx;
      const insetX = normalX * INSET;
      const insetY = normalY * INSET;
      
      const startX = (currentX - minX) + MAR + insetX;
      const startY = (currentY - minY) + MAR + insetY;
      
      let sideProgress = 0;
      
      // Gate detection logic (same as panel rendering)
      let gatePanelIndex = null;
      if (lay.gateSegment) {
        if (lay.gateSegment.panelIndex !== undefined) {
          gatePanelIndex = lay.gateSegment.panelIndex;
        } else {
          const totalPanels = lay.panelWidths.length;
          const position = lay.gateSegment.position || 'middle';
          if (position === 'left') {
            gatePanelIndex = Math.floor(totalPanels * 0.25);
          } else if (position === 'right') {
            gatePanelIndex = Math.floor(totalPanels * 0.75);
          } else {
            gatePanelIndex = Math.floor(totalPanels / 2);
          }
        }
      }
      
      lay.panelWidths.forEach((pw, panelIndex) => {
        const panelLen = pw * PX;
        
        // Calculate panel center position
        const panelMidX = startX + (sideProgress + panelLen/2) * unitDx;
        const panelMidY = startY + (sideProgress + panelLen/2) * unitDy;
        
        // Position label well inside the fence area (further from panel edges)
        const labelOffsetInward = INSET + LABEL_OFFSET + 8; // Much larger inward offset to move away from panel edges
        const labelX = panelMidX - normalX * labelOffsetInward; // Negative for inward
        const labelY = panelMidY - normalY * labelOffsetInward; // Negative for inward
        
        // Panel length label with proper orientation
        const t = document.createElementNS(NS,'text');
        t.textContent = `${Math.round(pw)} mm`;
        t.setAttribute('font-size', String(PANEL_FONT));
        t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', 'rgb(20,80,160)');
        t.setAttribute('text-anchor', 'middle');
        t.setAttribute('dominant-baseline', 'middle');
        
        // Keep text upright: flip if it would be upside-down
        const angle = Math.atan2(unitDy, unitDx) * 180 / Math.PI;
        const normalizedAngle = (angle + 360) % 360;
        const finalAngle = (normalizedAngle > 90 && normalizedAngle < 270) ? angle + 180 : angle;
        
        t.setAttribute('x', labelX);
        t.setAttribute('y', labelY);
        t.setAttribute('transform', `rotate(${finalAngle} ${labelX} ${labelY})`);
        svg.appendChild(t);

        sideProgress += panelLen;
        
        // Gate handling: add gate segment labels and spacing
        if (lay.gateSegment && panelIndex === gatePanelIndex && panelIndex < lay.panelWidths.length - 1) {
          const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
          
          if (hingeOnLeft) {
            // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
            // 5mm hinge label
            const hingeLen = 5 * PX;
            const hingeMidX = startX + (sideProgress + hingeLen/2) * unitDx;
            const hingeMidY = startY + (sideProgress + hingeLen/2) * unitDy;
            const hingeLabelX = hingeMidX - normalX * labelOffsetInward;
            const hingeLabelY = hingeMidY - normalY * labelOffsetInward;
            
            const hingeLabel = document.createElementNS(NS,'text');
            hingeLabel.textContent = '5mm H';
            hingeLabel.setAttribute('font-size', String(GAP_FONT));
            hingeLabel.setAttribute('font-weight', 'bold');
            hingeLabel.setAttribute('fill', '#cc6666');
            hingeLabel.setAttribute('text-anchor', 'middle');
            hingeLabel.setAttribute('dominant-baseline', 'middle');
            hingeLabel.setAttribute('x', hingeLabelX);
            hingeLabel.setAttribute('y', hingeLabelY);
            hingeLabel.setAttribute('transform', `rotate(${finalAngle} ${hingeLabelX} ${hingeLabelY})`);
            svg.appendChild(hingeLabel);
            
            sideProgress += hingeLen;
            
            // 890mm gate label
            const gateLen = 890 * PX;
            const gateMidX = startX + (sideProgress + gateLen/2) * unitDx;
            const gateMidY = startY + (sideProgress + gateLen/2) * unitDy;
            const gateLabelX = gateMidX - normalX * labelOffsetInward;
            const gateLabelY = gateMidY - normalY * labelOffsetInward;
            
            const gateLabel = document.createElementNS(NS,'text');
            gateLabel.textContent = '890mm GATE';
            gateLabel.setAttribute('font-size', String(PANEL_FONT));
            gateLabel.setAttribute('font-weight', 'bold');
            gateLabel.setAttribute('fill', '#006600');
            gateLabel.setAttribute('text-anchor', 'middle');
            gateLabel.setAttribute('dominant-baseline', 'middle');
            gateLabel.setAttribute('x', gateLabelX);
            gateLabel.setAttribute('y', gateLabelY);
            gateLabel.setAttribute('transform', `rotate(${finalAngle} ${gateLabelX} ${gateLabelY})`);
            svg.appendChild(gateLabel);
            
            sideProgress += gateLen;
            
            // 10mm latch label
            const latchLen = 10 * PX;
            const latchMidX = startX + (sideProgress + latchLen/2) * unitDx;
            const latchMidY = startY + (sideProgress + latchLen/2) * unitDy;
            const latchLabelX = latchMidX - normalX * labelOffsetInward;
            const latchLabelY = latchMidY - normalY * labelOffsetInward;
            
            const latchLabel = document.createElementNS(NS,'text');
            latchLabel.textContent = '10mm L';
            latchLabel.setAttribute('font-size', String(GAP_FONT));
            latchLabel.setAttribute('font-weight', 'bold');
            latchLabel.setAttribute('fill', '#339933');
            latchLabel.setAttribute('text-anchor', 'middle');
            latchLabel.setAttribute('dominant-baseline', 'middle');
            latchLabel.setAttribute('x', latchLabelX);
            latchLabel.setAttribute('y', latchLabelY);
            latchLabel.setAttribute('transform', `rotate(${finalAngle} ${latchLabelX} ${latchLabelY})`);
            svg.appendChild(latchLabel);
            
            sideProgress += latchLen;
          } else {
            // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
            // 10mm latch label
            const latchLen = 10 * PX;
            const latchMidX = startX + (sideProgress + latchLen/2) * unitDx;
            const latchMidY = startY + (sideProgress + latchLen/2) * unitDy;
            const latchLabelX = latchMidX - normalX * labelOffsetInward;
            const latchLabelY = latchMidY - normalY * labelOffsetInward;
            
            const latchLabel = document.createElementNS(NS,'text');
            latchLabel.textContent = '10mm L';
            latchLabel.setAttribute('font-size', String(GAP_FONT));
            latchLabel.setAttribute('font-weight', 'bold');
            latchLabel.setAttribute('fill', '#339933');
            latchLabel.setAttribute('text-anchor', 'middle');
            latchLabel.setAttribute('dominant-baseline', 'middle');
            latchLabel.setAttribute('x', latchLabelX);
            latchLabel.setAttribute('y', latchLabelY);
            latchLabel.setAttribute('transform', `rotate(${finalAngle} ${latchLabelX} ${latchLabelY})`);
            svg.appendChild(latchLabel);
            
            sideProgress += latchLen;
            
            // 890mm gate label
            const gateLen = 890 * PX;
            const gateMidX = startX + (sideProgress + gateLen/2) * unitDx;
            const gateMidY = startY + (sideProgress + gateLen/2) * unitDy;
            const gateLabelX = gateMidX - normalX * labelOffsetInward;
            const gateLabelY = gateMidY - normalY * labelOffsetInward;
            
            const gateLabel = document.createElementNS(NS,'text');
            gateLabel.textContent = '890mm GATE';
            gateLabel.setAttribute('font-size', String(PANEL_FONT));
            gateLabel.setAttribute('font-weight', 'bold');
            gateLabel.setAttribute('fill', '#006600');
            gateLabel.setAttribute('text-anchor', 'middle');
            gateLabel.setAttribute('dominant-baseline', 'middle');
            gateLabel.setAttribute('x', gateLabelX);
            gateLabel.setAttribute('y', gateLabelY);
            gateLabel.setAttribute('transform', `rotate(${finalAngle} ${gateLabelX} ${gateLabelY})`);
            svg.appendChild(gateLabel);
            
            sideProgress += gateLen;
            
            // 5mm hinge label
            const hingeLen = 5 * PX;
            const hingeMidX = startX + (sideProgress + hingeLen/2) * unitDx;
            const hingeMidY = startY + (sideProgress + hingeLen/2) * unitDy;
            const hingeLabelX = hingeMidX - normalX * labelOffsetInward;
            const hingeLabelY = hingeMidY - normalY * labelOffsetInward;
            
            const hingeLabel = document.createElementNS(NS,'text');
            hingeLabel.textContent = '5mm H';
            hingeLabel.setAttribute('font-size', String(GAP_FONT));
            hingeLabel.setAttribute('font-weight', 'bold');
            hingeLabel.setAttribute('fill', '#cc6666');
            hingeLabel.setAttribute('text-anchor', 'middle');
            hingeLabel.setAttribute('dominant-baseline', 'middle');
            hingeLabel.setAttribute('x', hingeLabelX);
            hingeLabel.setAttribute('y', hingeLabelY);
            hingeLabel.setAttribute('transform', `rotate(${finalAngle} ${hingeLabelX} ${hingeLabelY})`);
            svg.appendChild(hingeLabel);
            
            sideProgress += hingeLen;
          }
        } else if (panelIndex < lay.panelWidths.length - 1) {
          sideProgress += lay.gap * PX;
        }
      });
    });

    // LAYER 4: Gray gap labels (topmost)
    layouts.forEach((lay,i)=>{
      const run = customRuns[i];
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const unitDx = run.dx / length;
      const unitDy = run.dy / length;
      
      let currentX = 0, currentY = 0;
      for (let j = 0; j < i; j++) {
        currentX += customRuns[j].dx * PX;
        currentY += customRuns[j].dy * PX;
      }
      
      const normalX = -unitDy;
      const normalY = unitDx;
      const insetX = normalX * INSET;
      const insetY = normalY * INSET;
      
      const startX = (currentX - minX) + MAR + insetX;
      const startY = (currentY - minY) + MAR + insetY;
      
      let sideProgress = 0;
      
      lay.panelWidths.forEach((pw, panelIndex) => {
        sideProgress += pw * PX;
        
        if (panelIndex < lay.panelWidths.length - 1) {
          const gapLen = lay.gap * PX;
          
          // Calculate gap center position
          const gapMidX = startX + (sideProgress + gapLen/2) * unitDx;
          const gapMidY = startY + (sideProgress + gapLen/2) * unitDy;
          
          // Position gap label further away from glass (beyond red arrows)
          const labelOffsetTotal = INSET + LABEL_OFFSET;
          const gapLabelX = gapMidX + normalX * labelOffsetTotal;
          const gapLabelY = gapMidY + normalY * labelOffsetTotal;
          
          const gapText = document.createElementNS(NS,'text');
          gapText.textContent = `${Math.round(lay.gap)} mm`;
          gapText.setAttribute('font-size', String(GAP_FONT));
          gapText.setAttribute('font-weight', 'bold');
          gapText.setAttribute('fill', 'rgb(90,90,90)');
          gapText.setAttribute('text-anchor', 'middle');
          gapText.setAttribute('dominant-baseline', 'middle');
          
          // Keep text upright: flip if it would be upside-down
          const angle = Math.atan2(unitDy, unitDx) * 180 / Math.PI;
          const normalizedAngle = (angle + 360) % 360;
          const finalAngle = (normalizedAngle > 90 && normalizedAngle < 270) ? angle + 180 : angle;
          
          gapText.setAttribute('x', gapLabelX);
          gapText.setAttribute('y', gapLabelY);
          gapText.setAttribute('transform', `rotate(${finalAngle} ${gapLabelX} ${gapLabelY})`);
          svg.appendChild(gapText);
          
          sideProgress += gapLen;
        }
      });
    });

    return svg.outerHTML;
  }

  // PNG preview
document.getElementById('pdfBtn').onclick = async () => {
  try {
    if (!layouts.length) {
      alert('Please calculate first');
      return;
    }
    
    // Check if this is a custom shape and use appropriate plan generation
    let svg;
    if (window.customShapeData && window.customShapeData.isCustom && curShape && curShape.id === 'CUSTOM') {
      const svgString = buildCustomPlanSVG(layouts, window.customShapeData.runs);
      // Convert string to DOM element for XMLSerializer
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgString, 'image/svg+xml');
      svg = doc.documentElement;
    } else {
      svg = buildPlanSVG(layouts, sideLens);
    }
    
    if (!svg) {
      alert('Could not generate plan SVG');
      return;
    }
    const uri = 'data:image/svg+xml;base64,' + btoa(new XMLSerializer().serializeToString(svg));
    const png = await new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => {
        const scale = 1.5;
        const c = document.createElement('canvas');
        c.width = img.width * scale;
        c.height = img.height * scale;
        const ctx = c.getContext('2d');
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        ctx.drawImage(img, 0, 0);
        res(c.toDataURL('image/png'));
      };
      img.onerror = () => {
        alert('Failed to load plan image');
        rej();
      };
      img.src = uri;
    });

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // Accent bar
    const barWidth = pageWidth - 240;
    const barHeight = 48;
    const barX = (pageWidth - barWidth) / 2;
    const barY = 0;
    const barRadius = 24;

    pdf.setFillColor(0, 0, 0);
    pdf.roundedRect(barX, barY, barWidth, barHeight, barRadius, barRadius, 'F');

    // Title
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(22);
    pdf.text('Opus Hardware – Glass Fence Plan', pageWidth / 2, barY + 32, { align: 'center' });

    // Info box
    pdf.setFontSize(13);
    pdf.setTextColor(17, 17, 17);
    pdf.setFont('helvetica', 'normal');
    pdf.setDrawColor(234, 234, 234);
    pdf.setFillColor(255, 255, 255);
    pdf.roundedRect(40, 55, pageWidth - 80, 60, 10, 10, 'FD');
    pdf.text(`Shape: ${curShape.label}`, 60, 80);
    pdf.text(`Total Run: ${sideLens.reduce((a, b) => a + b, 0)} mm`, 60, 100);

    // Plan image
    const img2 = new Image();
    img2.src = png;
    img2.onload = () => {
      const marginX = 40, marginY = 130;
      const maxImgWidth = pageWidth - marginX * 2;
      const maxImgHeight = pageHeight - marginY - 60;
      const scale = Math.min(maxImgWidth / img2.width, maxImgHeight / img2.height, 1);
      const imgWidth = img2.width * scale;
      const imgHeight = img2.height * scale;
      const imgX = (pageWidth - imgWidth) / 2;
      const imgY = marginY + ((maxImgHeight - imgHeight) / 2);

      pdf.setDrawColor(234, 234, 234);
      pdf.setFillColor(255, 255, 255);
      pdf.roundedRect(imgX - 10, imgY - 10, imgWidth + 20, imgHeight + 20, 16, 16, 'FD');
      pdf.addImage(img2, 'PNG', imgX, imgY, imgWidth, imgHeight);

      // Footer text
      pdf.setFontSize(10);
      pdf.setTextColor(120, 120, 120);
      pdf.text('Generated by Opus Hardware SP14 Designer', 40, pageHeight - 24);

      // --- Add logo in bottom right ---
      const logoUrl = "https://cdn.shopify.com/s/files/1/0663/2738/0132/files/logomark_3eb73790-7aec-4bc9-ad74-0440d7517010.png?v=1729231583";
      const logoImg = new Image();
      logoImg.crossOrigin = "Anonymous";
      logoImg.src = logoUrl;

      logoImg.onload = () => {
const logoWidth = 60;   // wider
const logoHeight = 36;  // keep aspect ratio
const logoX = pageWidth - logoWidth - 32;
const logoY = pageHeight - logoHeight - 24;

pdf.addImage(logoImg, 'PNG', logoX, logoY, logoWidth, logoHeight);

        pdf.save('Opus_GlassPlan.pdf');
      };
      logoImg.onerror = () => {
        alert('Failed to load Opus logo for PDF');
        pdf.save('Opus_GlassPlan.pdf'); // Save anyway if logo fails
      };
    };
    img2.onerror = () => alert('Failed to load PNG for PDF');
  } catch (e) {
    alert('PDF generation failed: ' + e);
  }
};

// --- 3D View Generation ---
document.getElementById('view3dBtn').onclick = () => {
  try {
    if (!layouts.length) {
      alert('Please calculate first');
      return;
    }

    // Calculate fence geometry points using actual direction vectors
    let pts = [[0,0]];
    let x = 0, y = 0;
    
    if (window.customShapeData && window.customShapeData.isCustom) {
      // Use actual direction vectors from custom shape
      const customRuns = window.customShapeData.runs;
      const scale = 1; // Keep in mm for 3D
      customRuns.forEach((run, i) => {
        x += run.dx;
        y += run.dy;
        pts.push([x, y]);
      });
    } else {
      // Use default orthogonal directions for standard shapes
      const dirs = [[1,0],[0,1],[-1,0],[0,-1]];
      sideLens.forEach((l, i) => {
        x += dirs[i % 4][0] * l;
        y += dirs[i % 4][1] * l;
        pts.push([x, y]);
      });
    }

    // Prepare 3D view data with correct fence geometry
const sideCount = pts.length - 1;const runsAligned = [];for (let i = 0; i < sideCount; i++) {  const L = layouts[i];  if (L && Array.isArray(L.panelWidths)) { runsAligned.push(L); }  else {    const segLen = Math.hypot(pts[i+1][0]-pts[i][0], pts[i+1][1]-pts[i][1]);    runsAligned.push({ panelWidths: [], gap: 0, run: segLen, missing: true });  }}const fence = $('fenceType').value;const pool = fence === 'pool';const thk = $('glassThk').value;const ht = $('glassHt').value;const zone = $('windZone').value;let __maxSpacing = 400;let __edgeMax = 200;{const sys = pool ? 'pool' : 'balustrade';if (typeof ps14Lookup === 'function'){const row = ps14Lookup(sys, thk, ht, zone);if (row && row.internal < 999){__maxSpacing = row.internal;__edgeMax = row.edge;}}if (typeof EDGE_MIN !== 'undefined' && __edgeMax < EDGE_MIN) __edgeMax = EDGE_MIN;}const spMode = (document.querySelector('input[name="spigotMode"]:checked') || {}).value || 'auto';let __maxDiscsPerPanel = Infinity;if (spMode === '2') __maxDiscsPerPanel = 2;else if (spMode === '3') __maxDiscsPerPanel = 3;const view3dData = { runs: runsAligned, pts: pts, sideLens: sideLens, curShape: curShape, handrailType: $('handrailType').value, finishType: $('finishType').value, maxSpacing: __maxSpacing, edgeMax: __edgeMax, maxDiscsPerPanel: __maxDiscsPerPanel, pool: pool, thk: thk, ht: ht, zone: zone };

    // Create the 3D view HTML
    const html3d = generate3DViewHTML(view3dData);
    // Render the 3D view inside a full-screen iframe overlay instead of a
    // separate window.  Data URIs and document.write often fail in modern
    // browsers, especially when working from file:// origins.  An iframe
    // embedded via srcdoc ensures the HTML is executed properly in the same
    // origin.
    // Remove any existing 3D overlay/frame from previous views
    const existingFrame = document.getElementById('sp14-3d-frame');
    if (existingFrame) existingFrame.remove();
    const existingOverlay = document.getElementById('sp14-3d-close');
    if (existingOverlay) existingOverlay.remove();
    // Create the iframe to host the 3D HTML
    const frame = document.createElement('iframe');
    frame.id = 'sp14-3d-frame';
    frame.style.position = 'fixed';
    frame.style.top = '0';
    frame.style.left = '0';
    frame.style.width = '100%';
    frame.style.height = '100%';
    frame.style.zIndex = '10000';
    frame.style.border = 'none';
    // Use srcdoc to inject the generated HTML
    frame.srcdoc = html3d;
    document.body.appendChild(frame);
    // Add a close button overlay outside the iframe
    const closeOverlay = document.createElement('div');
    closeOverlay.id = 'sp14-3d-close';
    closeOverlay.style.position = 'fixed';
    closeOverlay.style.top = '10px';
    closeOverlay.style.right = '10px';
    closeOverlay.style.zIndex = '10001';
    // Replace default label and appearance with more visible "Exit 3D View" button
    closeOverlay.innerHTML = '<button style="padding:10px 16px;background:#0077c8;color:white;border:none;border-radius:4px;cursor:pointer;font-size:14px;font-weight:bold;">Exit&nbsp;3D&nbsp;View</button>';
    closeOverlay.firstChild.onclick = function() {
      if (frame.parentNode) frame.parentNode.removeChild(frame);
      if (closeOverlay.parentNode) closeOverlay.parentNode.removeChild(closeOverlay);
      // Remove the controls panel if present
      const controlsEl = document.getElementById('sp14-3d-controls');
      if (controlsEl && controlsEl.parentNode) controlsEl.parentNode.removeChild(controlsEl);
      // Restore page scrolling when exiting 3D view
      document.body.style.overflow = '';
    };
    document.body.appendChild(closeOverlay);
    // Add live calculation controls (spigot mode, mixed panels, recalc) below the exit button
    const controlsDiv = document.createElement('div');
    controlsDiv.id = 'sp14-3d-controls';
    controlsDiv.style.position = 'fixed';
    controlsDiv.style.bottom = '20px';
    controlsDiv.style.right = '10px';
    controlsDiv.style.zIndex = '10002';
    controlsDiv.style.background = 'rgba(255,255,255,0.95)';
    controlsDiv.style.padding = '12px';
    controlsDiv.style.borderRadius = '4px';
    controlsDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
    controlsDiv.style.fontSize = '14px';
    controlsDiv.innerHTML = `
      <div style="margin-bottom:6px;font-weight:bold;">Recalculate Options</div>
      <div style="margin-bottom:4px;">
        <label><input type="radio" name="spigotModeOverlay" value="auto"> Auto</label>
        <label style="margin-left:8px;"><input type="radio" name="spigotModeOverlay" value="2"> 2&nbsp;posts&nbsp;per&nbsp;panel</label>
        <label style="margin-left:8px;"><input type="radio" name="spigotModeOverlay" value="3"> 3&nbsp;posts&nbsp;per&nbsp;panel</label>
      </div>
      <div style="margin-bottom:8px;">
        <label><input type="checkbox" id="allowMixedOverlay"> Allow mixed panels</label>
      </div>
      <button id="recalc3dBtn" style="padding:8px 12px;background:#0077c8;color:white;border:none;border-radius:4px;cursor:pointer;">Recalculate</button>
    `;
    // Initialize overlay controls to match current settings on the page
    {
      const currentMode = (document.querySelector('input[name="spigotMode"]:checked') || {}).value || 'auto';
      const modeInput = controlsDiv.querySelector(`input[name="spigotModeOverlay"][value="${currentMode}"]`);
      if (modeInput) modeInput.checked = true;
      const allowMixedCheckbox = document.getElementById('allowMixed');
      if (allowMixedCheckbox) controlsDiv.querySelector('#allowMixedOverlay').checked = allowMixedCheckbox.checked;
    }
    // Bind recalc button
    controlsDiv.querySelector('#recalc3dBtn').onclick = function() {
      // Propagate selected spigot mode to main form
      const selectedMode = (controlsDiv.querySelector('input[name="spigotModeOverlay"]:checked') || {}).value || 'auto';
      const targetRadio = document.querySelector(`input[name="spigotMode"][value="${selectedMode}"]`);
      if (targetRadio) targetRadio.checked = true;
      // Propagate allowMixed
      const allowMixedBox = controlsDiv.querySelector('#allowMixedOverlay');
      const mainAllowMixed = document.getElementById('allowMixed');
      if (mainAllowMixed) mainAllowMixed.checked = !!allowMixedBox.checked;
      // Trigger recalculation on the main page
      const calcBtn = document.getElementById('calcBtn');
      if (calcBtn) calcBtn.click();
      // Remove old overlay and controls
      if (frame.parentNode) frame.parentNode.removeChild(frame);
      if (closeOverlay.parentNode) closeOverlay.parentNode.removeChild(closeOverlay);
      if (controlsDiv.parentNode) controlsDiv.parentNode.removeChild(controlsDiv);
      // Reopen 3D view using the updated settings
      const viewBtn = document.getElementById('view3dBtn');
      if (viewBtn) viewBtn.click();
    };
    document.body.appendChild(controlsDiv);
    // Prevent background page from scrolling while the 3D view is open and jump to top
    document.body.style.overflow = 'hidden';
    window.scrollTo(0, 0);
    return;
    
  } catch (e) {
    alert('3D view generation failed: ' + e);
  }
};

function generate3DViewHTML(data) {
  var html = '<!DOCTYPE html><html><head><title>3D Fence Plan View</title>';
  html += '<style>body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #f0f0f0; }</style>';
  html += '<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>';
  html += '<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"><\/script>';
  html += '</head><body>';
  html += '<div style="position: absolute; top: 10px; left: 10px; color: #333; z-index: 100; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 5px;">';
  html += '<strong>3D Fence Plan View</strong><br>Mouse: Orbit | Wheel: Zoom | Right-click: Pan</div>';
  html += '<div style="position: absolute; top: 10px; right: 10px; z-index: 100;">';
  html += '<button onclick="resetCamera()" style="padding: 8px 12px; margin: 2px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; background: #0077c8; color: white;">Reset View</button>';
  // Removed the in-frame Close button – the overlay provides its own Exit 3D View button
  html += '</div>';
  
  html += '<script>';
  html += 'const layoutData = ' + JSON.stringify(data) + ';';
  html += 'const scene = new THREE.Scene();';
  html += 'scene.background = new THREE.Color(0xf0f0f0);';
  html += 'const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);';
  html += 'const renderer = new THREE.WebGLRenderer({ antialias: true });renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));';
  html += 'renderer.setSize(window.innerWidth, window.innerHeight);';
  html += 'document.body.appendChild(renderer.domElement);function onWindowResize(){camera.aspect = window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth, window.innerHeight);}window.addEventListener("resize", onWindowResize);';
  html += 'const controls = new THREE.OrbitControls(camera, renderer.domElement);';
  // Set a provisional camera position; final position will be computed after scene creation
  html += 'camera.position.set(5, 4, 5);';
  html += 'controls.target.set(0, 0, 0);controls.enableDamping = true;controls.dampingFactor = 0.08;controls.minDistance = 1.5;controls.maxDistance = 50;controls.maxPolarAngle = Math.PI * 0.49;controls.minPolarAngle = Math.PI * 0.05;';
  html += 'const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);';
  html += 'scene.add(ambientLight);';
  
  html += 'function createCustomGround() {';
  html += 'if (!layoutData || !layoutData.pts || layoutData.pts.length === 0) return;';
  html += 'const pts = layoutData.pts;';
  html += 'if (pts.length < 3) return;';
  html += 'const scale = 0.002;';
  html += 'try {';
  html += 'const scaledPoints = pts.map(pt => new THREE.Vector2(pt[0] * scale, -pt[1] * scale));';
  html += 'const area = scaledPoints.reduce((a, p, i) => {';
  html += 'const q = scaledPoints[(i + 1) % scaledPoints.length];';
  html += 'return a + (p.x * q.y - q.x * p.y);';
  html += '}, 0);';
  html += 'if (area < 0) scaledPoints.reverse();';
  html += 'const shape = new THREE.Shape(scaledPoints);';
  html += 'const groundGeometry = new THREE.ShapeGeometry(shape);';
  html += 'groundGeometry.rotateX(-Math.PI / 2);';
  html += 'groundGeometry.translate(0, 0.001, 0);';
  html += 'const groundMaterial = new THREE.MeshStandardMaterial({';
  html += 'color: 0xaaaaaa,';
  html += 'roughness: 0.85,';
  html += 'metalness: 0,';
  html += 'transparent: true,';
  html += 'opacity: 0.7,';
  html += 'side: THREE.DoubleSide';
  html += '});';
  html += 'const ground = new THREE.Mesh(groundGeometry, groundMaterial);';
  html += 'if (window.floorMesh) {';
  html += 'scene.remove(window.floorMesh);';
  html += 'window.floorMesh.geometry.dispose();';
  html += 'window.floorMesh.material.dispose();';
  html += '}';
  html += 'scene.add(ground);';
  html += 'window.floorMesh = ground;';
  html += '} catch (e) {';
  html += 'console.warn("Floor creation failed:", e);';
  html += '}';
  html += '}';
  html += 'createCustomGround();';
  
  html += 'function createFence3D() {';
  html += 'function faceOutward(mesh, startPt, endPt) {';
  html += 'const normal = new THREE.Vector3(endPt[1] - startPt[1], 0, -(endPt[0] - startPt[0])).normalize();';
  html += 'mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);';
  html += '}';
  html += 'const BOTTOM_OFFSET = 0.08;';
  html += 'const ROW_SPACING = 0.16;';
  html += 'const runs = layoutData.runs || [];';
  html += 'const pts = layoutData.pts || [];';
  html += 'if (runs.length === 0 || pts.length === 0) { console.warn("No fence data"); return; }';
  html += 'console.log("3D Data:", { runs: runs, pts: pts });';
  html += 'runs.forEach((layout, sideIndex) => {';
  html += 'if (!pts[sideIndex] || !pts[sideIndex + 1]) return;';
  html += 'const startPt = pts[sideIndex];';
  html += 'const endPt = pts[sideIndex + 1];';
  html += 'const dx = endPt[0] - startPt[0];';
  html += 'const dy = endPt[1] - startPt[1];';
  html += 'const scale = 0.002;';
  html += 'let currentPos = 0;';
  html += 'if (!layout.panelWidths || !layout.panelWidths.length) { /* side has no solution, skip drawing panels but keep index */ return; }';
  html += 'let gatePanelIndex = null;';
  html += 'if (layout.gateSegment) {';
  html += 'if (layout.gateSegment.panelIndex !== undefined) {';
  html += 'gatePanelIndex = layout.gateSegment.panelIndex;';
  html += '} else {';
  html += 'const totalPanels = layout.panelWidths.length;';
  html += 'const position = layout.gateSegment.position || "middle";';
  html += 'if (position === "left") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.25);';
  html += '} else if (position === "right") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.75);';
  html += '} else {';
  html += 'gatePanelIndex = Math.floor(totalPanels / 2);';
  html += '}';
  html += '}';
  html += '}';
  html += 'layout.panelWidths.forEach((panelWidth, panelIndex) => {';
  html += 'const panelLength = panelWidth * scale;';
  html += 'const panelHeight = 2.4;';
  html += 'const geometry = new THREE.BoxGeometry(panelLength, panelHeight, 0.024);';
  html += 'const material = new THREE.MeshLambertMaterial({ color: 0x88ccee, transparent: true, opacity: 0.7 });';
  html += 'const panel = new THREE.Mesh(geometry, material);';
  html += 'const sideLength = Math.sqrt(dx * dx + dy * dy);';
  html += 'const progress = (currentPos + panelLength / 2) / (sideLength * scale);';
  html += 'const x = startPt[0] * scale + dx * scale * progress;';
  html += 'const z = startPt[1] * scale + dy * scale * progress;';
  html += 'panel.position.set(x, panelHeight / 2, z);';
  html += 'const angle = Math.atan2(dy, dx);';
  html += 'panel.rotation.y = -angle;';
  html += 'scene.add(panel);';
  
  // Add disc visualization based on actual solver parameters
  html += 'const maxSpacing = (layoutData.maxSpacing || 400);';
  html += 'const edgeMax = (layoutData.edgeMax || 200);';
  // Calculate how many spigots are required for this panel. At least 2 spigots per panel.
  html += 'let spigotCount = Math.max(2, Math.ceil((panelWidth - 2 * edgeMax) / maxSpacing) + 1);';
  html += 'const maxPerPanel = (layoutData.maxDiscsPerPanel || Infinity);';
  html += 'if (spigotCount > maxPerPanel) spigotCount = maxPerPanel;';
  html += 'const spigotSpacing = (panelWidth - 2 * edgeMax) / Math.max(1, spigotCount - 1);';
  // Use SP14 spigot geometry: a rectangular post 0.04m x 0.04m footprint and 0.35m tall (approximate dimensions based on SP14 drawing).
  // SP14 spigot dimensions: approximate 80 mm wide at base, 42 mm wide at top. Use 0.08 m width and 0.04 m depth, 0.344 m height.
  // Use a cylindrical spigot so that posts stand upright.  Radius 0.04m, height 0.344m, 16 segments for a smooth round profile.
  html += 'const spigotGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.344, 16);';
  html += 'const spigotMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });';
  html += 'for (let d = 0; d < spigotCount; d++) {';
  html += '  const spigotOffset = edgeMax + d * spigotSpacing;';
  html += '  const spigotProgress = (currentPos + spigotOffset * scale) / (sideLength * scale);';
  html += '  const spigotX = startPt[0] * scale + dx * scale * spigotProgress;';
  html += '  const spigotZ = startPt[1] * scale + dy * scale * spigotProgress;';
  // Offset spigots slightly off the glass line so they appear in front of the glass when viewed obliquely.
  html += '  const offsetX = dx !== 0 ? 0 : (dy > 0 ? 0.02 : -0.02);';
  html += '  const offsetZ = dy !== 0 ? 0 : (dx > 0 ? -0.02 : 0.02);';
  html += '  const spigot = new THREE.Mesh(spigotGeometry, spigotMaterial);';
  // Align spigot with the fence direction.  A cylinder rotates around its Y axis without changing its vertical orientation.
  html += '  spigot.rotation.y = -angle;';
  // Position spigot so its base sits at BOTTOM_OFFSET and centre of the panel width
  html += '  spigot.position.set(spigotX + offsetX, BOTTOM_OFFSET + 0.35/2, spigotZ + offsetZ);';
  // Orient spigot to face outward relative to the panel direction
  // Orient the spigot only around the Y-axis to align with the fence direction.  Avoid rotating on X/Z so spigots remain vertical.
  html += '  spigot.rotation.y = -angle;';
  html += '  scene.add(spigot);';
  html += '}';
  
  html += 'currentPos += panelLength;';
  
  // Check if this is the gate position and add gate geometry in the gap
  html += 'if (layout.gateSegment && panelIndex === gatePanelIndex && panelIndex < layout.panelWidths.length - 1) {';
  html += 'let gateCurrentPos = currentPos;';
  html += 'const hingeOnLeft = layout.gateSegment.hingeOnLeft !== undefined ? layout.gateSegment.hingeOnLeft : false;';
  html += 'if (hingeOnLeft) {';
  // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
  // 5mm hinge (light red) - positioned at start of gap
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeGeometry = new THREE.BoxGeometry(5 * scale, panelHeight, 0.024);';
  html += 'const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0xffcccc, transparent: true, opacity: 0.8 });';
  html += 'const hingePanel = new THREE.Mesh(hingeGeometry, hingeMaterial);';
  html += 'hingePanel.position.set(hingeX, panelHeight / 2, hingeZ);';
  html += 'hingePanel.rotation.y = -angle;';
  html += 'scene.add(hingePanel);';
  html += 'gateCurrentPos += 5 * scale;';
  // 890mm gate (green) - positioned after hinge
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateGeometry = new THREE.BoxGeometry(890 * scale, panelHeight, 0.024);';
  html += 'const gateMaterial = new THREE.MeshLambertMaterial({ color: 0x90ee90, transparent: true, opacity: 0.7 });';
  html += 'const gateMainPanel = new THREE.Mesh(gateGeometry, gateMaterial);';
  html += 'gateMainPanel.position.set(gateX, panelHeight / 2, gateZ);';
  html += 'gateMainPanel.rotation.y = -angle;';
  html += 'scene.add(gateMainPanel);';
  html += 'gateCurrentPos += 890 * scale;';
  // 10mm latch (light green) - positioned after gate
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchGeometry = new THREE.BoxGeometry(10 * scale, panelHeight, 0.024);';
  html += 'const latchMaterial = new THREE.MeshLambertMaterial({ color: 0xccffcc, transparent: true, opacity: 0.8 });';
  html += 'const latchPanel = new THREE.Mesh(latchGeometry, latchMaterial);';
  html += 'latchPanel.position.set(latchX, panelHeight / 2, latchZ);';
  html += 'latchPanel.rotation.y = -angle;';
  html += 'scene.add(latchPanel);';
  html += '} else {';
  // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
  // 10mm latch (light green) - positioned at start of gap
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchGeometry = new THREE.BoxGeometry(10 * scale, panelHeight, 0.024);';
  html += 'const latchMaterial = new THREE.MeshLambertMaterial({ color: 0xccffcc, transparent: true, opacity: 0.8 });';
  html += 'const latchPanel = new THREE.Mesh(latchGeometry, latchMaterial);';
  html += 'latchPanel.position.set(latchX, panelHeight / 2, latchZ);';
  html += 'latchPanel.rotation.y = -angle;';
  html += 'scene.add(latchPanel);';
  html += 'gateCurrentPos += 10 * scale;';
  // 890mm gate (green) - positioned after latch
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateGeometry = new THREE.BoxGeometry(890 * scale, panelHeight, 0.024);';
  html += 'const gateMaterial = new THREE.MeshLambertMaterial({ color: 0x90ee90, transparent: true, opacity: 0.7 });';
  html += 'const gateMainPanel = new THREE.Mesh(gateGeometry, gateMaterial);';
  html += 'gateMainPanel.position.set(gateX, panelHeight / 2, gateZ);';
  html += 'gateMainPanel.rotation.y = -angle;';
  html += 'scene.add(gateMainPanel);';
  html += 'gateCurrentPos += 890 * scale;';
  // 5mm hinge (light red) - positioned after gate
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeGeometry = new THREE.BoxGeometry(5 * scale, panelHeight, 0.024);';
  html += 'const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0xffcccc, transparent: true, opacity: 0.8 });';
  html += 'const hingePanel = new THREE.Mesh(hingeGeometry, hingeMaterial);';
  html += 'hingePanel.position.set(hingeX, panelHeight / 2, hingeZ);';
  html += 'hingePanel.rotation.y = -angle;';
  html += 'scene.add(hingePanel);';
  html += 'gateCurrentPos += 5 * scale;';
  html += '}';
  html += 'currentPos = gateCurrentPos;';
  html += '}';
  
  html += 'const hasGateAtThisPosition = (layout.gateSegment && panelIndex === gatePanelIndex);';
  html += 'if (panelIndex < layout.panelWidths.length - 1 && !hasGateAtThisPosition) {';
  html += 'currentPos += (layout.gap || 8) * scale;';
  html += '}';
  html += '});';
  html += '});';
  html += '}';
  
  html += 'function addDimensionLabels() {';
  html += 'const runs = layoutData.runs || [];';
  html += 'const pts = layoutData.pts || [];';
  html += 'if (runs.length === 0 || pts.length === 0) return;';
  html += 'const scale = 0.002;';
  html += 'const loader = new THREE.FontLoader();';
  html += 'const fontUrl = "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";';
  html += 'loader.load(fontUrl, function(font) {';
  html += 'runs.forEach((layout, sideIndex) => {';
  html += 'if (!pts[sideIndex] || !pts[sideIndex + 1]) return;';
  html += 'const startPt = pts[sideIndex];';
  html += 'const endPt = pts[sideIndex + 1];';
  html += 'const dx = endPt[0] - startPt[0];';
  html += 'const dy = endPt[1] - startPt[1];';
  html += 'const sideLength = Math.sqrt(dx * dx + dy * dy);';
  html += 'const midX = (startPt[0] + endPt[0]) / 2 * scale;';
  html += 'const midZ = (startPt[1] + endPt[1]) / 2 * scale;';
  html += 'const runLengthText = Math.round(sideLength) + "mm";';html += 'const textGeometry = new THREE.TextGeometry(runLengthText, {';html += 'font: font,';html += 'size: 0.15,';html += 'height: 0.02,';html += 'curveSegments: 12,';html += 'bevelEnabled: true,';html += 'bevelThickness: 0.005,';html += 'bevelSize: 0.002,';html += 'bevelSegments: 3';html += '});';html += 'textGeometry.computeBoundingBox();';html += 'if (textGeometry.center) { textGeometry.center(); } else { const bb2=textGeometry.boundingBox; const xMid2=(bb2.max.x+bb2.min.x)/2; textGeometry.translate(-xMid2,0,0); }';html += 'const textMaterial = new THREE.MeshPhongMaterial({ ';
  html += 'color: 0x000000,';
  html += 'shininess: 30,';
  html += 'specular: 0x444444';
  html += '});';
  html += 'const textMesh = new THREE.Mesh(textGeometry, textMaterial);';
  html += 'const textBBox = textGeometry.boundingBox;';
  html += 'const textWidth = textBBox.max.x - textBBox.min.x;';
  html += 'const textHeight = textBBox.max.y - textBBox.min.y;';
  html += 'textMesh.position.set(midX, 2.6, midZ);';
  html += 'const angle = Math.atan2(dy, dx);';
  html += 'textMesh.rotation.y = -angle + Math.PI;';
  
  html += 'const padding = 0.05;';
  html += 'const bgGeometry = new THREE.PlaneGeometry(textWidth + padding * 2, textHeight + padding * 2);';
  html += 'const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });';
  html += 'const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);';
  html += 'bgMesh.position.set(midX, 2.6, midZ);';
  html += 'bgMesh.rotation.copy(textMesh.rotation);';
  html += 'bgMesh.rotation.z = Math.PI;';
  html += 'scene.add(bgMesh);';
  html += 'scene.add(textMesh);';
  html += 'let currentPos = 0;';
  html += 'let gatePanelIndex = null;';
  html += 'if (layout.gateSegment) {';
  html += 'if (layout.gateSegment.panelIndex !== undefined) {';
  html += 'gatePanelIndex = layout.gateSegment.panelIndex;';
  html += '} else {';
  html += 'const totalPanels = layout.panelWidths.length;';
  html += 'const position = layout.gateSegment.position || "middle";';
  html += 'if (position === "left") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.25);';
  html += '} else if (position === "right") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.75);';
  html += '} else {';
  html += 'gatePanelIndex = Math.floor(totalPanels / 2);';
  html += '}';
  html += '}';
  html += '}';
  html += 'layout.panelWidths.forEach((panelWidth, panelIndex) => {';
  html += 'const panelLength = panelWidth * scale;';
  html += 'const progress = (currentPos + panelLength / 2) / (sideLength * scale);';
  html += 'const panelMidX = startPt[0] * scale + dx * scale * progress;';
  html += 'const panelMidZ = startPt[1] * scale + dy * scale * progress;';
  html += 'const panelText = panelWidth + "mm";';html += 'const panelTextGeometry = new THREE.TextGeometry(panelText, {';html += 'font: font, size: 0.15, height: 0.02';html += '});';html += 'const panelTextMaterial = new THREE.MeshBasicMaterial({ color: 0x0066cc });';html += 'const panelTextMesh = new THREE.Mesh(panelTextGeometry, panelTextMaterial);';html += 'panelTextGeometry.computeBoundingBox();';html += 'if (panelTextGeometry.center) { panelTextGeometry.center(); } else { const bb=panelTextGeometry.boundingBox; const xMid=(bb.max.x+bb.min.x)/2; panelTextGeometry.translate(-xMid,0,0); }';html += 'const normalX = Math.sin(-angle);';html += 'const normalZ = Math.cos(-angle);';html += 'panelTextMesh.position.set(panelMidX - normalX * 0.5, 1.5, panelMidZ - normalZ * 0.5);';html += 'panelTextMesh.rotation.y = -angle + Math.PI;';html += 'scene.add(panelTextMesh);';
  html += 'currentPos += panelLength;';
  html += 'if (layout.gateSegment && panelIndex === gatePanelIndex && panelIndex < layout.panelWidths.length - 1) {';
  html += 'let gateCurrentPos = currentPos;';
  html += 'const hingeOnLeft = layout.gateSegment.hingeOnLeft !== undefined ? layout.gateSegment.hingeOnLeft : false;';
  html += 'if (hingeOnLeft) {';
  // Add hinge label (5mm)
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeLabelX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeLabelZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeTextGeometry = new THREE.TextGeometry("5mm H", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const hingeTextMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });';
  html += 'const hingeTextMesh = new THREE.Mesh(hingeTextGeometry, hingeTextMaterial);';
  html += 'hingeTextGeometry.computeBoundingBox();';
  html += 'const hingeTextWidth = hingeTextGeometry.boundingBox.max.x - hingeTextGeometry.boundingBox.min.x;';
  html += 'const hingeOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const hingeOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'hingeTextMesh.position.set(hingeLabelX - hingeTextWidth/2 + hingeOffsetX, 1.0, hingeLabelZ + hingeOffsetZ);';
  html += 'hingeTextMesh.rotation.y = -angle;';
  html += 'scene.add(hingeTextMesh);';
  html += 'gateCurrentPos += 5 * scale;';
  // Add gate label (890mm)
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateLabelX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateLabelZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateTextGeometry = new THREE.TextGeometry("890mm GATE", {';
  html += 'font: font, size: 0.05, height: 0.01';
  html += '});';
  html += 'const gateTextMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa00 });';
  html += 'const gateTextMesh = new THREE.Mesh(gateTextGeometry, gateTextMaterial);';
  html += 'gateTextGeometry.computeBoundingBox();';
  html += 'const gateTextWidth = gateTextGeometry.boundingBox.max.x - gateTextGeometry.boundingBox.min.x;';
  html += 'const gateOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const gateOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'gateTextMesh.position.set(gateLabelX - gateTextWidth/2 + gateOffsetX, 1.0, gateLabelZ + gateOffsetZ);';
  html += 'gateTextMesh.rotation.y = -angle;';
  html += 'scene.add(gateTextMesh);';
  html += 'gateCurrentPos += 890 * scale;';
  // Add latch label (10mm)
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchLabelX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchLabelZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchTextGeometry = new THREE.TextGeometry("10mm L", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const latchTextMaterial = new THREE.MeshBasicMaterial({ color: 0x66ff66 });';
  html += 'const latchTextMesh = new THREE.Mesh(latchTextGeometry, latchTextMaterial);';
  html += 'latchTextGeometry.computeBoundingBox();';
  html += 'const latchTextWidth = latchTextGeometry.boundingBox.max.x - latchTextGeometry.boundingBox.min.x;';
  html += 'const latchOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const latchOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'latchTextMesh.position.set(latchLabelX - latchTextWidth/2 + latchOffsetX, 1.0, latchLabelZ + latchOffsetZ);';
  html += 'latchTextMesh.rotation.y = -angle;';
  html += 'scene.add(latchTextMesh);';
  html += 'gateCurrentPos += 10 * scale;';
  html += '} else {';
  // Reverse order: latch → gate → hinge
  // Add latch label (10mm)
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchLabelX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchLabelZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchTextGeometry = new THREE.TextGeometry("10mm L", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const latchTextMaterial = new THREE.MeshBasicMaterial({ color: 0x66ff66 });';
  html += 'const latchTextMesh = new THREE.Mesh(latchTextGeometry, latchTextMaterial);';
  html += 'latchTextGeometry.computeBoundingBox();';
  html += 'const latchTextWidth = latchTextGeometry.boundingBox.max.x - latchTextGeometry.boundingBox.min.x;';
  html += 'const latchOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const latchOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'latchTextMesh.position.set(latchLabelX - latchTextWidth/2 + latchOffsetX, 1.0, latchLabelZ + latchOffsetZ);';
  html += 'latchTextMesh.rotation.y = -angle;';
  html += 'scene.add(latchTextMesh);';
  html += 'gateCurrentPos += 10 * scale;';
  // Add gate label (890mm)
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateLabelX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateLabelZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateTextGeometry = new THREE.TextGeometry("890mm GATE", {';
  html += 'font: font, size: 0.05, height: 0.01';
  html += '});';
  html += 'const gateTextMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa00 });';
  html += 'const gateTextMesh = new THREE.Mesh(gateTextGeometry, gateTextMaterial);';
  html += 'gateTextGeometry.computeBoundingBox();';
  html += 'const gateTextWidth = gateTextGeometry.boundingBox.max.x - gateTextGeometry.boundingBox.min.x;';
  html += 'const gateOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const gateOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'gateTextMesh.position.set(gateLabelX - gateTextWidth/2 + gateOffsetX, 1.0, gateLabelZ + gateOffsetZ);';
  html += 'gateTextMesh.rotation.y = -angle;';
  html += 'scene.add(gateTextMesh);';
  html += 'gateCurrentPos += 890 * scale;';
  // Add hinge label (5mm)
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeLabelX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeLabelZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeTextGeometry = new THREE.TextGeometry("5mm H", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const hingeTextMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });';
  html += 'const hingeTextMesh = new THREE.Mesh(hingeTextGeometry, hingeTextMaterial);';
  html += 'hingeTextGeometry.computeBoundingBox();';
  html += 'const hingeTextWidth = hingeTextGeometry.boundingBox.max.x - hingeTextGeometry.boundingBox.min.x;';
  html += 'const hingeOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const hingeOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'hingeTextMesh.position.set(hingeLabelX - hingeTextWidth/2 + hingeOffsetX, 1.0, hingeLabelZ + hingeOffsetZ);';
  html += 'hingeTextMesh.rotation.y = -angle;';
  html += 'scene.add(hingeTextMesh);';
  html += 'gateCurrentPos += 5 * scale;';
  html += '}';
  html += 'currentPos = gateCurrentPos;';
  html += '} else if (panelIndex < layout.panelWidths.length - 1) {';
  html += 'currentPos += (layout.gap || 8) * scale;';
  html += '}';
  html += '});';
  html += '});';
  html += '});';
  
  // Add handrails if selected
  html += 'const handrailType = ' + JSON.stringify(data.handrailType || 'none') + ';';
  html += 'if (handrailType && handrailType !== "none") {';
  html += 'try {';
  html += 'const RAIL_PROFILES = {';
  html += '  "AH40": { dims: [0.040, 0.036], bevel: 0 },';
  html += '  "S25": { dims: [0.025, 0.021], bevel: 0.002 },';
  html += '  "S40": { dims: [0.040, 0.030], bevel: 0.002 },';
  html += '  "R40": { dia: 0.042 }';
  html += '};';
  html += 'const profile = RAIL_PROFILES[handrailType];';
  html += 'if (profile) {';
  html += 'const finishType = ' + JSON.stringify(data.finishType || 'mill') + ';';
  html += 'const isBlackFinish = finishType.toLowerCase().includes("black") || finishType.toLowerCase().includes("matt black");';
  html += 'let railMaterial;';
  html += 'if (isBlackFinish) {';
  html += 'railMaterial = new THREE.MeshStandardMaterial({';
  html += 'color: 0x2a2a2a,';
  html += 'metalness: 0.7,';
  html += 'roughness: 0.4,';
  html += 'envMapIntensity: 0.8';
  html += '});';
  html += '} else {';
  html += 'railMaterial = new THREE.MeshPhysicalMaterial({';
  html += 'color: 0xbfc5c9,';
  html += 'metalness: 0.85,';
  html += 'roughness: 0.25,';
  html += 'envMapIntensity: 1.2,';
  html += 'clearcoat: 0.1,';
  html += 'clearcoatRoughness: 0.3';
  html += '});';
  html += '}';
  html += 'let railGeometry;';
  html += 'if (profile.dims) {';
  html += 'const [w, h] = profile.dims;';
  html += 'railGeometry = new THREE.BoxGeometry(1, h, w);';
  html += '} else if (profile.dia) {';
  html += 'const r = profile.dia / 2;';
  html += 'railGeometry = new THREE.CylinderGeometry(r, r, 1, 24);';
  html += 'railGeometry.rotateZ(Math.PI / 2);';
  html += '}';
  html += 'runs.forEach((layout, sideIndex) => {';
  html += 'if (!pts[sideIndex] || !pts[sideIndex + 1]) return;';
  html += 'const startPt = pts[sideIndex];';
  html += 'const endPt = pts[sideIndex + 1];';
  html += 'const dx = endPt[0] - startPt[0];';
  html += 'const dy = endPt[1] - startPt[1];';
  html += 'const scale = 0.002;';
  html += 'const sideLength = Math.sqrt(dx * dx + dy * dy);';
  html += 'let currentPos = 0;';
  html += 'layout.panelWidths.forEach((panelWidth, panelIndex) => {';
  html += 'const panelLength = panelWidth * scale;';
  html += 'const rail = new THREE.Mesh(railGeometry, railMaterial);';
  html += 'const progress = (currentPos + panelLength / 2) / (sideLength * scale);';
  html += 'const x = startPt[0] * scale + dx * scale * progress;';
  html += 'const z = startPt[1] * scale + dy * scale * progress;';
  html += 'const panelHeight = 2.4;';
  html += 'rail.position.set(x, panelHeight + 0.02, z);';
  html += 'const angle = Math.atan2(dy, dx);';
  html += 'rail.rotation.y = -angle;';
  html += 'rail.scale.x = panelLength;';
  html += 'scene.add(rail);';
  html += 'currentPos += panelLength;';
  html += 'if (layout.gateSegment && panelIndex === layout.gateSegment.panelIndex) {';
  html += 'const __gateW = ((layout.gateSegment && (layout.gateSegment.totalWidth || layout.gateSegment.width)) ? (layout.gateSegment.totalWidth || layout.gateSegment.width) : 905) * scale; currentPos += __gateW;';
  html += '} else if (panelIndex < layout.panelWidths.length - 1) {';
  html += 'currentPos += (layout.gap || 8) * scale;';
  html += '}';
  html += '});';
  html += '});';
  html += '}';
  html += '} catch (e) {';
  html += 'console.warn("Handrail creation failed:", e);';
  html += '}';
  html += '}';
  html += '}';
  
  html += 'createFence3D();';
  html += 'addDimensionLabels();';
  // Set a fixed camera position that provides a good diagonal view over the
  // fence.  Dynamic bounding-box logic can sometimes produce a blank
  // screen when called before the geometry fully exists.  A static
  // position avoids this issue and still offers a clear perspective on
  // most layouts.  Adjust the values here if you find the view too near
  // or too far.
  // Set the static camera far enough away to view most shapes.  The x/z
  // offsets of 8 and a height of around 4.5 provide a clear oblique view
  // without clipping the fence.  Adjust these values to taste.
  html += 'camera.position.set(8, 4.5, 8);';
  html += 'controls.target.set(0, 0, 0);';
  html += 'controls.update();';
  // Reset function returns to the same static position
  html += 'function resetCamera() { camera.position.set(8, 4.5, 8); controls.target.set(0, 0, 0); controls.update(); }';
  html += 'function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }';
  html += 'window.addEventListener("resize", () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });';
  html += 'animate();';
  html += '<\/script>';
  html += '</body></html>';
  
  return html;
}

// --- Freehand SVG Pad Logic with Ghost Line, Larger Area, and 10x Scale ---
const svgPad = document.getElementById('svgGridPad');
const svgSection = document.getElementById('svgDrawSection');
const sideLengthsDiv = document.getElementById('svgSideLengths');
const submitBtn = document.getElementById('svgSubmitLayoutBtn');
const clearBtn = document.getElementById('svgClearBtn');
const doneBtn = document.getElementById('svgDoneBtn');
const editBtn = document.getElementById('svgEditBtn');

svgPad.setAttribute('width', '1200');
svgPad.setAttribute('height', '800');

// Zoom and pan variables for mouse wheel zoom
let zoomLevel = 1;
let panX = 600;  // Center X (half of 1200)
let panY = 400;  // Center Y (half of 800)
let isPanning = false;
let lastPanX = 0;
let lastPanY = 0;

const MM_PER_PIXEL = 10;

// Helper function to snap measurements to 5mm increments
function snapTo5mm(length) {
  const rawLength = Math.sqrt(length) * MM_PER_PIXEL;
  return Math.round(rawLength / 5) * 5;
}

// Helper function to snap angles to 5-degree increments
function snapTo5Degrees(angle) {
  return Math.round(angle / 5) * 5;
}

// Helper function to calculate angle between two lines in degrees
function calculateAngle(prevPoint, currentPoint, nextPoint) {
  // Vector from previous to current point
  const v1x = currentPoint.x - prevPoint.x;
  const v1y = currentPoint.y - prevPoint.y;
  
  // Vector from current to next point
  const v2x = nextPoint.x - currentPoint.x;
  const v2y = nextPoint.y - currentPoint.y;
  
  // Calculate angle using dot product and cross product
  const dot = v1x * v2x + v1y * v2y;
  const cross = v1x * v2y - v1y * v2x;
  
  let angle = Math.atan2(cross, dot) * (180 / Math.PI);
  
  // Convert to positive angle (0-360)
  if (angle < 0) angle += 360;
  
  // Return the supplementary angle (180 - angle) to start from 180°
  angle = 180 - angle;
  if (angle < 0) angle += 360;
  if (angle > 180) angle = 360 - angle;
  
  return snapTo5Degrees(angle);
}

// Function to detect corners and determine required joiners
function detectCornersAndJoiners() {
  let corners = [];
  
  // Check corners in finished shapes
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    
    // Find corners within each shape (need at least 3 points)
    if (shape.length >= 3) {
      for (let i = 1; i < shape.length - 1; i++) {
        const prevPoint = shape[i - 1];
        const currentPoint = shape[i];
        const nextPoint = shape[i + 1];
        
        const angle = calculateAngle(prevPoint, currentPoint, nextPoint);
        
        // Only consider significant angle changes (not straight lines)
        if (Math.abs(angle - 180) > 10) { // 10 degree tolerance for "straight"
          corners.push({
            point: currentPoint,
            angle: angle,
            shapeIndex: shapeIndex,
            pointIndex: i,
            isNinetyDegree: angle === 90 // Only EXACTLY 90 degrees
          });
        }
      }
    }
  }
  
  // Check for connection points between different shapes (where shapes meet)
  const tolerance = 5; // 5 pixel tolerance for connection detection
  for(let shape1Index = 0; shape1Index < finishedShapes.length; shape1Index++) {
    const shape1 = finishedShapes[shape1Index];
    for(let shape2Index = shape1Index + 1; shape2Index < finishedShapes.length; shape2Index++) {
      const shape2 = finishedShapes[shape2Index];
      
      // Check if any endpoints of shape1 connect to any points of shape2
      [0, shape1.length - 1].forEach(shape1PointIndex => {
        const shape1Point = shape1[shape1PointIndex];
        
        shape2.forEach((shape2Point, shape2PointIndex) => {
          const distance = Math.sqrt(
            Math.pow(shape1Point.x - shape2Point.x, 2) + 
            Math.pow(shape1Point.y - shape2Point.y, 2)
          );
          
          if (distance <= tolerance) {
            // Found a connection! Calculate the actual angle at this point
            let angle = 180; // Default to straight line
            
            // Get the adjacent points to calculate the real angle
            let prevPoint = null;
            let nextPoint = null;
            
            // Get adjacent point from shape1
            if (shape1PointIndex === 0 && shape1.length > 1) {
              prevPoint = shape1[1]; // Next point in shape1
            } else if (shape1PointIndex === shape1.length - 1 && shape1.length > 1) {
              prevPoint = shape1[shape1.length - 2]; // Previous point in shape1
            }
            
            // Get adjacent point from shape2
            if (shape2PointIndex === 0 && shape2.length > 1) {
              nextPoint = shape2[1]; // Next point in shape2
            } else if (shape2PointIndex === shape2.length - 1 && shape2.length > 1) {
              nextPoint = shape2[shape2.length - 2]; // Previous point in shape2
            } else if (shape2PointIndex > 0 && shape2PointIndex < shape2.length - 1) {
              // Connection is in middle of shape2, use appropriate adjacent point
              nextPoint = shape2PointIndex === 0 ? shape2[1] : shape2[shape2PointIndex - 1];
            }
            
            // Calculate angle if we have both adjacent points
            if (prevPoint && nextPoint) {
              angle = calculateAngle(prevPoint, shape1Point, nextPoint);
            }
            
            // Add as corner only if it's not a straight line
            if (Math.abs(angle - 180) > 10) { // 10 degree tolerance for "straight"
              corners.push({
                point: shape1Point, // Use shape1 point as reference
                angle: angle,
                shapeIndex: shape1Index,
                pointIndex: shape1PointIndex,
                isNinetyDegree: Math.abs(angle - 90) < 5, // 5 degree tolerance for 90 degrees
                isConnection: true // Flag to indicate this is a connection point
              });
            }
          }
        });
      });
    }
  }
  
  // Check corners in current drawing
  if (points.length >= 3) {
    for (let i = 1; i < points.length - 1; i++) {
      const prevPoint = points[i - 1];
      const currentPoint = points[i];
      const nextPoint = points[i + 1];
      
      const angle = calculateAngle(prevPoint, currentPoint, nextPoint);
      
      // Only consider significant angle changes (not straight lines)  
      if (Math.abs(angle - 180) > 10) { // 10 degree tolerance for "straight"
        corners.push({
          point: currentPoint,
          angle: angle,
          shapeIndex: -1, // -1 indicates current drawing
          pointIndex: i,
          isNinetyDegree: angle === 90 // Only EXACTLY 90 degrees
        });
      }
    }
  }
  
  return corners;
}

// Function to get joiner code based on handrail type and angle
function getJoinerCode(handrailType, isNinetyDegree) {
  if (isNinetyDegree) {
    // 90 degree corner joiners
    switch(handrailType) {
      case 'S25': return 'S25J90';
      case 'S40': return 'S40J90';
      case 'AH40': return 'AHJ90';
      case 'R40': return 'R40J90';
      default: return 'J90'; // Generic if handrail type not recognized
    }
  } else {
    // Adjustable horizontal joiners
    switch(handrailType) {
      case 'S25': return 'S25HAJ';
      case 'S40': return 'S40HAJ';
      case 'AH40': return 'AHAHJ';
      case 'R40': return 'R40HAJ';
      default: return 'HAJ'; // Generic if handrail type not recognized
    }
  }
}

// Zoom utility functions
function updateViewBox() {
  const width = 1200 / zoomLevel;
  const height = 800 / zoomLevel;
  const x = panX - width / 2;
  const y = panY - height / 2;
  svgPad.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
}

function handleMouseWheel(e) {
  // Only zoom when Ctrl key is held down
  if (!e.ctrlKey) {
    return; // Allow normal scrolling behavior
  }
  
  e.preventDefault();
  
  // Get mouse position relative to SVG
  const rect = svgPad.getBoundingClientRect();
  const mouseX = (e.clientX - rect.left) / rect.width * 1200;
  const mouseY = (e.clientY - rect.top) / rect.height * 800;
  
  // Determine zoom direction and factor
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.5, Math.min(5, zoomLevel * zoomFactor));
  
  if (newZoom !== zoomLevel) {
    // Zoom towards mouse position
    panX += (mouseX - panX) * (1 - newZoom / zoomLevel);
    panY += (mouseY - panY) * (1 - newZoom / zoomLevel);
    zoomLevel = newZoom;
    updateViewBox();
  }
}

// Pan functions for Ctrl+drag
function handleMouseDown(e) {
  if (e.ctrlKey && e.button === 0) { // Ctrl + Left mouse button for pan
    e.preventDefault();
    isPanning = true;
    lastPanX = e.clientX;
    lastPanY = e.clientY;
    svgPad.style.cursor = 'move';
    wasMouseMoved = false; // Reset movement tracking
  }
}

function handleMouseMove(e) {
  if (isPanning) {
    e.preventDefault();
    e.stopPropagation(); // Prevent drawing while panning
    
    const deltaX = (e.clientX - lastPanX) / zoomLevel;
    const deltaY = (e.clientY - lastPanY) / zoomLevel;
    panX -= deltaX;
    panY -= deltaY;
    lastPanX = e.clientX;
    lastPanY = e.clientY;
    updateViewBox();
    wasMouseMoved = true; // Mark that mouse was moved during pan
    return; // Don't process as drawing move
  }
}

function handleMouseUp(e) {
  if (isPanning) {
    isPanning = false;
    svgPad.style.cursor = 'crosshair';
    e.preventDefault();
    e.stopPropagation(); // Prevent click from registering as drawing
    
    // Set a timeout to clear the movement flag to prevent clicks immediately after panning
    setTimeout(() => {
      wasMouseMoved = false;
    }, 100);
  }
}

let points = [];
let finishedShapes = []; // Array of completed shapes (each shape is an array of points)
let ghost = null;
let isDrawingMode = true; // Track drawing state
let currentDrawingPoint = null; // Track which point we're drawing from
let currentDrawingPointIndex = null; // Track the index of the point we're drawing from
const SNAP_R = 15; // px radius to “grab” an old point

// Helper function to check if a point is already connected in the sequence
function isPointInSequence(point, pointsArray) {
  return pointsArray.some(p => p.x === point.x && p.y === point.y);
}

function nearestPoint(mx, my) {
  let hit = -1, best = SNAP_R * SNAP_R;
  points.forEach((p, i) => {
    const dx = mx - p.x, dy = my - p.y, d2 = dx*dx + dy*dy;
    if (d2 < best) { best = d2; hit = i; }
  });
  return hit;
}

function clientToSvg(e){
  // Create an SVG point
  const pt = svgPad.createSVGPoint();
  pt.x = e.clientX;
  pt.y = e.clientY;
  
  // Transform the point from screen coordinates to SVG coordinates
  // This automatically accounts for all transformations including viewBox
  const svgPt = pt.matrixTransform(svgPad.getScreenCTM().inverse());
  
  return { x: svgPt.x, y: svgPt.y };
}

function drawFreehandPad() {
  svgPad.innerHTML = '';
  
  // Add grid pattern
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
  pattern.setAttribute('id', 'grid');
  pattern.setAttribute('width', '50');
  pattern.setAttribute('height', '50');
  pattern.setAttribute('patternUnits', 'userSpaceOnUse');
  
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M 50 0 L 0 0 0 50');
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', '#e0e0e0');
  path.setAttribute('stroke-width', '1');
  
  pattern.appendChild(path);
  defs.appendChild(pattern);
  svgPad.appendChild(defs);
  
  // Add grid background - make it extend far beyond the viewable area
  const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  gridRect.setAttribute('x', '-10000');
  gridRect.setAttribute('y', '-10000');
  gridRect.setAttribute('width', '20000');
  gridRect.setAttribute('height', '20000');
  gridRect.setAttribute('fill', 'url(#grid)');
  svgPad.appendChild(gridRect);
  
  let globalSideCounter = 0; // Counter for side labeling across all shapes
  
  // Draw all finished shapes with labels
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    for(let k=1; k<shape.length; k++) {
      const a = shape[k-1], b = shape[k];
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',a.x);line.setAttribute('y1',a.y);
      line.setAttribute('x2',b.x);line.setAttribute('y2',b.y);
      line.setAttribute('stroke','#888'); // Slightly lighter for finished shapes
      line.setAttribute('stroke-width',2);
      svgPad.appendChild(line);
      
      // Add side label for finished shapes
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
      const sideLetter = String.fromCharCode(65 + globalSideCounter); // A, B, C, etc.
      
      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.textContent = `${sideLetter}: ${len} mm`;
      lbl.setAttribute('x', mx);
      lbl.setAttribute('y', my - 8);
      lbl.setAttribute('font-size', '14');
      lbl.setAttribute('fill', '#666'); // Slightly lighter for finished shapes
      lbl.setAttribute('font-weight', '600');
      lbl.setAttribute('text-anchor', 'middle');
      lbl.setAttribute('pointer-events', 'none'); // Prevent blocking clicks
      svgPad.appendChild(lbl);
      
      globalSideCounter++;
    }
  }
  
  // Draw current active drawing lines with labels
  for(let k=1;k<points.length;k++) {
    const a = points[k-1], b = points[k];
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x);line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x);line.setAttribute('y2',b.y);
    line.setAttribute('stroke','#222');
    line.setAttribute('stroke-width',3);
    svgPad.appendChild(line);
    
    // Add side label for active drawing
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
    const sideLetter = String.fromCharCode(65 + globalSideCounter); // Continue lettering
    
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = `${sideLetter}: ${len} mm`;
    lbl.setAttribute('x', mx);
    lbl.setAttribute('y', my - 8);
    lbl.setAttribute('font-size', '14');
    lbl.setAttribute('fill', '#0077c8'); // Blue for active drawing
    lbl.setAttribute('font-weight', '600');
    lbl.setAttribute('text-anchor', 'middle');
    lbl.setAttribute('pointer-events', 'none'); // Prevent blocking clicks
    svgPad.appendChild(lbl);
    
    globalSideCounter++;
  }
  
  // Draw clickable point circles when not in drawing mode
  if (!isDrawingMode) {
    // Show blue dots for current points
    for(let i=0; i<points.length; i++) {
      const point = points[i];
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx', point.x);
      circle.setAttribute('cy', point.y);
      circle.setAttribute('r', '15');
      circle.setAttribute('fill', '#0077c8');
      circle.setAttribute('stroke', '#fff');
      circle.setAttribute('stroke-width', '3');
      circle.setAttribute('cursor', 'pointer');
      circle.setAttribute('data-point-index', i);
      circle.addEventListener('click', (e) => {
        e.stopPropagation();
        resumeDrawingFromPoint(i);
      });
      svgPad.appendChild(circle);
    }
    
    // Show blue dots for finished shapes
    for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
      const shape = finishedShapes[shapeIndex];
      for(let pointIndex = 0; pointIndex < shape.length; pointIndex++) {
        const point = shape[pointIndex];
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '12');
        circle.setAttribute('fill', '#0077c8');
        circle.setAttribute('stroke', '#fff');
        circle.setAttribute('stroke-width', '2');
        circle.setAttribute('cursor', 'pointer');
        circle.addEventListener('click', (e) => {
          e.stopPropagation();
          resumeDrawingFromFinishedPoint(shapeIndex, pointIndex);
        });
        svgPad.appendChild(circle);
      }
    }
  } else {
    // In drawing mode, show blue dots only if currentDrawingPoint is not set (user needs to select starting point)
    if (!currentDrawingPoint && points.length > 0) {
      for(let i=0; i<points.length; i++) {
        const point = points[i];
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '15');
        circle.setAttribute('fill', '#0077c8');
        circle.setAttribute('stroke', '#fff');
        circle.setAttribute('stroke-width', '3');
        circle.setAttribute('cursor', 'pointer');
        circle.setAttribute('data-point-index', i);
        circle.addEventListener('click', (e) => {
          e.stopPropagation();
          resumeDrawingFromPoint(i);
        });
        svgPad.appendChild(circle);
      }
    }
  }
  // Draw ghost line if present
  if(currentDrawingPoint && ghost) {
    const a = currentDrawingPoint, b = ghost;
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x);line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x);line.setAttribute('y2',b.y);
    line.setAttribute('stroke','#0077c8');
    line.setAttribute('stroke-width',2);
    line.setAttribute('stroke-dasharray','8,6');
    svgPad.appendChild(line);
    // Live measurement label for ghost line
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = `${len} mm`;
    lbl.setAttribute('x', mx);
    lbl.setAttribute('y', my - 18);
    lbl.setAttribute('font-size', '16');
    lbl.setAttribute('fill', '#0077c8');
    lbl.setAttribute('text-anchor', 'middle');
    lbl.setAttribute('font-weight', 'bold');
    svgPad.appendChild(lbl);
    
    // Show angle indicator if we have a previous point
    if(points.length >= 2) {
      const prevPoint = points[points.length - 2];
      const angle = calculateAngle(prevPoint, a, b);
      
      // Create angle arc indicator
      const radius = 40;
      const startAngle = Math.atan2(prevPoint.y - a.y, prevPoint.x - a.x);
      const endAngle = Math.atan2(b.y - a.y, b.x - a.x);
      
      const startX = a.x + radius * Math.cos(startAngle);
      const startY = a.y + radius * Math.sin(startAngle);
      const endX = a.x + radius * Math.cos(endAngle);
      const endY = a.y + radius * Math.sin(endAngle);
      
      // Calculate arc direction (shortest path)
      let angleDiff = endAngle - startAngle;
      if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
      const sweepFlag = angleDiff > 0 ? 1 : 0;
      const largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;
      
      const arc = document.createElementNS('http://www.w3.org/2000/svg','path');
      const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
      arc.setAttribute('d', pathData);
      arc.setAttribute('stroke', '#0077c8');
      arc.setAttribute('stroke-width', 2);
      arc.setAttribute('fill', 'none');
      arc.setAttribute('stroke-dasharray', '4,3');
      svgPad.appendChild(arc);
      
      // Create angle label
      const labelRadius = radius + 20;
      const labelAngle = (startAngle + endAngle) / 2;
      const labelX = a.x + labelRadius * Math.cos(labelAngle);
      const labelY = a.y + labelRadius * Math.sin(labelAngle);
      
      const angleLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      angleLabel.setAttribute('x', labelX);
      angleLabel.setAttribute('y', labelY + 5);
      angleLabel.setAttribute('text-anchor', 'middle');
      angleLabel.setAttribute('font-size', '14');
      angleLabel.setAttribute('fill', '#0077c8');
      angleLabel.setAttribute('font-weight', 'bold');
      angleLabel.textContent = angle + '°';
      svgPad.appendChild(angleLabel);
    }
    
    // Draw + cursor at ghost point
    const cross1 = document.createElementNS('http://www.w3.org/2000/svg','line');
    cross1.setAttribute('x1', b.x - 10); cross1.setAttribute('y1', b.y);
    cross1.setAttribute('x2', b.x + 10); cross1.setAttribute('y2', b.y);
    cross1.setAttribute('stroke', '#0077c8');
    cross1.setAttribute('stroke-width', 2);
    svgPad.appendChild(cross1);
    const cross2 = document.createElementNS('http://www.w3.org/2000/svg','line');
    cross2.setAttribute('x1', b.x); cross2.setAttribute('y1', b.y - 10);
    cross2.setAttribute('x2', b.x); cross2.setAttribute('y2', b.y + 10);
    cross2.setAttribute('stroke', '#0077c8');
    cross2.setAttribute('stroke-width', 2);
    svgPad.appendChild(cross2);
  }
  // Draw points
  points.forEach((p,i) => {
    const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx',p.x);dot.setAttribute('cy',p.y);
    dot.setAttribute('r',7);
    dot.setAttribute('fill','#0077c8');
    svgPad.appendChild(dot);
    // Label point
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = String.fromCharCode(65+i);
    lbl.setAttribute('x',p.x+12);lbl.setAttribute('y',p.y-12);
    lbl.setAttribute('font-size','16');lbl.setAttribute('fill','#0077c8');
    lbl.setAttribute('font-weight','bold');
    svgPad.appendChild(lbl);
  });
  // Draw side labels
  for(let k=1;k<points.length;k++) {
    const a = points[k-1], b = points[k];
    const mx = (a.x+b.x)/2, my = (a.y+b.y)/2;
    const len = Math.round(Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2) * MM_PER_PIXEL);
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = String.fromCharCode(65+k-1)+': '+len+' mm';
    lbl.setAttribute('x',mx);lbl.setAttribute('y',my-10);
    lbl.setAttribute('font-size','14');lbl.setAttribute('fill','#0077c8');
    lbl.setAttribute('text-anchor','middle');
    lbl.setAttribute('font-weight','600');
    svgPad.appendChild(lbl);
  }
  
  // Draw corner markers
  const corners = detectCornersAndJoiners();
  corners.forEach((corner, index) => {
    // Draw corner marker circle
    const marker = document.createElementNS('http://www.w3.org/2000/svg','circle');
    marker.setAttribute('cx', corner.point.x);
    marker.setAttribute('cy', corner.point.y);
    marker.setAttribute('r', '18');
    marker.setAttribute('fill', corner.isNinetyDegree ? '#28a745' : '#ffc107'); // Green for 90°, yellow for adjustable
    marker.setAttribute('stroke', '#fff');
    marker.setAttribute('stroke-width', '3');
    marker.setAttribute('opacity', '0.8');
    svgPad.appendChild(marker);
    
    // Add corner angle text
    const cornerText = document.createElementNS('http://www.w3.org/2000/svg','text');
    cornerText.textContent = corner.isNinetyDegree ? '90°' : `${corner.angle}°`;
    cornerText.setAttribute('x', corner.point.x);
    cornerText.setAttribute('y', corner.point.y + 5);
    cornerText.setAttribute('font-size', '12');
    cornerText.setAttribute('font-weight', 'bold');
    cornerText.setAttribute('fill', '#fff');
    cornerText.setAttribute('text-anchor', 'middle');
    cornerText.setAttribute('pointer-events', 'none');
    svgPad.appendChild(cornerText);
  });
}

svgPad.onclick = function(e) {
  // Prevent drawing if we just finished panning or if Ctrl is held down
  if (isPanning || e.ctrlKey) return;
  
  if (!isDrawingMode) return; // Only allow clicks in drawing mode
  if (!currentDrawingPoint && points.length > 0) return; // Must select a blue dot first if points exist
  
  let newPoint;
  
  // If we have a ghost point (which is already angle-snapped), use that exact position
  if (ghost) {
    newPoint = { x: ghost.x, y: ghost.y }; // Use the exact snapped ghost position
  } else {
    // Fallback to direct mouse position if no ghost
    newPoint = clientToSvg(e);
  }
  
  // Normal drawing - just add to end of current drawing
  points.push(newPoint);
  currentDrawingPoint = newPoint; // Update current drawing point to the new point
  ghost = null;
  drawFreehandPad();
  updateFreehandSideLengths();
};

svgPad.onmousemove = function(e) {
  // If we're panning, the handleMouseMove will handle it
  if (isPanning) {
    return;
  }
  
  // Don't show ghost lines when Ctrl is held down (navigation mode)
  if (e.ctrlKey) {
    return;
  }
  
  if(currentDrawingPoint && isDrawingMode) { // Only show ghost line when a drawing point is selected
    let mousePoint = clientToSvg(e);
    
    // Apply angle snapping if we have a previous point to reference
    if (points.length > 0) {
      const referencePoint = points[points.length - 1]; // Last drawn point
      ghost = snapPointToAngle(referencePoint, mousePoint, 5); // Snap to 5-degree increments
    } else {
      ghost = mousePoint; // No snapping for first point
    }
    
    drawFreehandPad();
  }
};

// Function to snap a point to angle-snapped position relative to a reference point
function snapPointToAngle(referencePoint, currentPoint, increment = 5) {
  const dx = currentPoint.x - referencePoint.x;
  const dy = currentPoint.y - referencePoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < 1) return currentPoint; // Too close to snap meaningfully
  
  // Calculate the current angle in degrees
  const currentAngleDegrees = Math.atan2(dy, dx) * (180 / Math.PI);
  
  // FORCE snap to nearest 5-degree increment
  const snappedAngleDegrees = Math.round(currentAngleDegrees / increment) * increment;
  
  // Convert back to radians
  const snappedAngleRadians = snappedAngleDegrees * (Math.PI / 180);
  
  // Return point at EXACT snapped angle
  return {
    x: referencePoint.x + distance * Math.cos(snappedAngleRadians),
    y: referencePoint.y + distance * Math.sin(snappedAngleRadians)
  };
}

svgPad.onmouseleave = function() {
  ghost = null;
  drawFreehandPad();
};

  // --- Glass Order PDF Generation ---
  // Define the base64-encoded Opus logo for embedding into the glass order PDF. This small logo (approx 200px width) is included here to avoid external requests.
  const OPUS_LOGO_SMALL = 'data:image/png;base64,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';

  // Attach click handler to the Glass Order button.  This handler generates a PDF listing each side's panel widths and gaps using the current layouts and PS13 specs.  It renders a header bar, info box with shape and total run, lists panels and gate widths, and embeds the Opus logo at the bottom.
  const orderBtn = document.getElementById('orderPdfBtn');
if (orderBtn) orderBtn.onclick = async () => {
    try {
      // Ensure we have calculated layouts before generating the order
      if (!Array.isArray(layouts) || layouts.length === 0) {
        alert('Please calculate first');
        return;
      }
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
      const pageWidth  = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();

      // Determine the selected glass thickness and derive its descriptive type
      const glassThkEl = document.getElementById('glassThk');
      const glassThkVal = glassThkEl && glassThkEl.value ? glassThkEl.value : '';
      let glassTypeName = '';
      if (glassThkVal === '13.52' || glassThkVal === '17.52') {
        glassTypeName = 'Sentry Laminate';
      } else if (glassThkVal) {
        glassTypeName = 'Toughened';
      }
      const glassNote = glassThkVal ? `${glassThkVal}mm ${glassTypeName}` : '';

      // Compute FFL height + 50 mm to determine ordering height (not displayed on diagram anymore)
      const fflStr = document.getElementById('glassHt')?.value || '0';
      const fflHeight = parseInt(fflStr, 10) || 0;
      const glassHeightOrder = fflHeight + 50;

      // Extract unique panel/gate widths and counts across layouts
      const uniqueMap = {};
      layouts.forEach((lay) => {
        if (Array.isArray(lay.panelWidths)) {
          lay.panelWidths.forEach((pw) => {
            const key = `panel_${pw}`;
            if (uniqueMap[key]) uniqueMap[key].count++;
            else uniqueMap[key] = { width: pw, type: 'panel', count: 1 };
          });
        }
        if (lay.gateSegment) {
          // Use actual gate width if provided; fall back to 905 but we will display 890mm in the drawing
          const gWidth = lay.gateSegment.totalWidth || lay.gateSegment.width || 905;
          const key2 = `gate_${gWidth}`;
          if (uniqueMap[key2]) uniqueMap[key2].count++;
          else uniqueMap[key2] = { width: gWidth, type: 'gate', count: 1 };
        }
      });
      const uniquePanels = Object.values(uniqueMap);
      uniquePanels.sort((a, b) => b.width - a.width);

      // Function to draw header and info box on each page
      function drawHeaderAndInfo() {
        // Header bar
        const barW = pageWidth - 120;
        const barH = 40;
        const barX = (pageWidth - barW) / 2;
        const barY = 0;
        const barR = 20;
        pdf.setFillColor(0, 0, 0);
        pdf.roundedRect(barX, barY, barW, barH, barR, barR, 'F');
        pdf.setTextColor(255, 255, 255);
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(20);
        pdf.text('Opus Hardware – SP14 Glass Order', pageWidth / 2, barY + 27, { align: 'center' });

        // Info box; height increased to accommodate glass note
        pdf.setTextColor(17, 17, 17);
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(12);
        const infoX = 40;
        const infoY = barY + barH + 20;
        const infoW = pageWidth - 80;
        const infoH = 70;
        pdf.setDrawColor(234, 234, 234);
        pdf.setFillColor(255, 255, 255);
        pdf.roundedRect(infoX, infoY, infoW, infoH, 8, 8, 'FD');
        const shapeLabel = curShape && curShape.label ? curShape.label : 'Unknown';
        const totalRun = sideLens.reduce((a, b) => a + b, 0);
        pdf.text(`Shape: ${shapeLabel}`, infoX + 20, infoY + 20);
        pdf.text(`Total Run: ${totalRun} mm`, infoX + 20, infoY + 36);
        if (glassNote) {
          pdf.text(`Glass: ${glassNote}`, infoX + 20, infoY + 52);
        }
        // Return the y coordinate at which panel rows should start
        return infoY + infoH + 20;
      }

      // Initial page header and compute starting Y
      let currentY = drawHeaderAndInfo();

      // Define rectangle dimensions
      const rectW  = 300;
      const rectH  = 80;
      const rowGap = 40;

      // For each unique panel, draw its representation
      uniquePanels.forEach((panel) => {
        // Check if the next rectangle would overflow the page; if so, start a new page
        if (currentY + rectH > pageHeight - 80) {
          pdf.addPage();
          currentY = drawHeaderAndInfo();
        }
        const rectX = 60;
        const rectY = currentY;
        // Fill color: green for gate, blue for panel
        if (panel.type === 'gate') {
          pdf.setFillColor(198, 231, 198);
        } else {
          pdf.setFillColor(200, 220, 255);
        }
        pdf.setDrawColor(160, 160, 160);
        pdf.rect(rectX, rectY, rectW, rectH, 'FD');

        // Draw horizontal dimension arrow above the rectangle
        const arrowY = rectY - 12;
        const arrowSize = 6;
        pdf.setDrawColor(0, 0, 0);
        pdf.setLineWidth(1);
        pdf.line(rectX, arrowY, rectX + rectW, arrowY);
        // Left arrowhead
        pdf.line(rectX, arrowY, rectX + arrowSize, arrowY - arrowSize / 2);
        pdf.line(rectX, arrowY, rectX + arrowSize, arrowY + arrowSize / 2);
        // Right arrowhead
        pdf.line(rectX + rectW, arrowY, rectX + rectW - arrowSize, arrowY - arrowSize / 2);
        pdf.line(rectX + rectW, arrowY, rectX + rectW - arrowSize, arrowY + arrowSize / 2);
        // Width label (use 890mm for gate panels)
        const widthLabel = panel.type === 'gate' ? 890 : panel.width;
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(20, 20, 20);
        pdf.text(`${widthLabel}mm`, rectX + rectW / 2, arrowY - 3, { align: 'center' });

        // Label gate panels explicitly in centre of the rectangle
        if (panel.type === 'gate') {
          pdf.setFontSize(14);
          pdf.setFont('helvetica', 'bold');
          pdf.setTextColor(60, 60, 60);
          pdf.text('Gate Panel', rectX + rectW / 2, rectY + rectH / 2 + 4, { align: 'center' });
        }

        // Draw quantity outside the right edge when count > 1 (or always show count)
        if (panel.count > 0) {
          const qtyX = rectX + rectW + 10;
          const qtyY = rectY + rectH / 2 + 5;
          // Larger, bold red quantity outside the panel
          pdf.setFontSize(26);
          pdf.setFont('helvetica', 'bold');
          pdf.setTextColor(255, 0, 0);
          pdf.text(`x${panel.count}`, qtyX, qtyY, { align: 'left' });
        }

        // Advance Y position for next row
        currentY += rectH + rowGap;
      });

      // Add footer and logo to the last page
      function addFooterAndLogo() {
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(120, 120, 120);
        pdf.text('Generated by Opus Hardware SP14 Designer', 40, pageHeight - 40);
        const logoImg = new Image();
        logoImg.src = OPUS_LOGO_SMALL;
        logoImg.onload = () => {
          const logoW = 80;
          const logoH = 40;
          const logoX = pageWidth - logoW - 40;
          const logoY = pageHeight - logoH - 32;
          pdf.addImage(logoImg, 'PNG', logoX, logoY, logoW, logoH);
        pdf.save('Opus_SP14_GlassOrder.pdf');
        };
        logoImg.onerror = () => {
        pdf.save('Opus_SP14_GlassOrder.pdf');
        };
      }

      // If we added new pages, ensure footer/logo only added once, after last page
      addFooterAndLogo();

    } catch (err) {
      alert('Failed to generate Glass Order PDF: ' + err);
    }
  };

function updateFreehandSideLengths() {
  let html = '';
  let sideCounter = 0;
  
  // Add measurements for finished shapes
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    for(let k=1; k<shape.length; k++) {
      const a = shape[k-1], b = shape[k];
      const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
      html += `
        <div style="display:inline-block; margin:2px 8px; padding:6px; background:rgba(0,119,200,0.1); border-radius:3px; text-align:center;">
          <div style="font-weight:bold; margin-bottom:4px;">Side ${String.fromCharCode(65+sideCounter)}: ${len} mm</div>
          <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.85rem;color:#444;cursor:pointer;justify-content:center;margin-top:2px;">
            <input type="checkbox" class="customGateRequired" data-side="${sideCounter}" style="margin:0;transform:scale(1.1);">
            <span style="font-weight:500;">Gate</span>
          </label>
        </div>`;
      sideCounter++;
    }
  }
  
  // Add measurements for current active drawing
  for(let k=1; k<points.length; k++) {
    const a = points[k-1], b = points[k];
    const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
    html += `
      <div style="display:inline-block; margin:2px 8px; padding:6px; background:rgba(0,119,200,0.1); border-radius:3px; text-align:center;">
        <div style="font-weight:bold; margin-bottom:4px;">Side ${String.fromCharCode(65+sideCounter)}: ${len} mm</div>
        <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.85rem;color:#444;cursor:pointer;justify-content:center;margin-top:2px;">
          <input type="checkbox" class="customGateRequired" data-side="${sideCounter}" style="margin:0;transform:scale(1.1);">
          <span style="font-weight:500;">Gate</span>
        </label>
      </div>`;
    sideCounter++;
  }
  
  sideLengthsDiv.innerHTML = html || 'Click points on the drawing area to start creating your fence layout...';
  
  // Add event handlers for custom gate checkboxes
  if (sideCounter > 0) {
    document.querySelectorAll('.customGateRequired').forEach(checkbox => {
      checkbox.onchange = () => {
        drawFreehandPad(); // Refresh the drawing
        // Don't call updateFreehandSideLengths() here to avoid infinite loop
      };
    });
  }
}

function showSvgPad() {
  points = [];
  ghost = null;
  currentDrawingPoint = null;
  isDrawingMode = true;
  updateUI();
  drawFreehandPad();
  updateFreehandSideLengths();
  svgSection.style.display = '';
}

function clearSvgPad() {
  // Show confirmation dialog before clearing
  const confirmClear = confirm('Are you sure you want to clear the entire drawing? This action cannot be undone.');
  
  if (!confirmClear) {
    return; // User cancelled, don't clear
  }
  
  // Save state before clearing
  saveDrawingState();
  
  points = [];
  finishedShapes = []; // Also clear finished shapes
  ghost = null;
  currentDrawingPoint = null; // Reset current drawing point
  isDrawingMode = true; // Reset to drawing mode
  updateUI();
  drawFreehandPad();
  updateFreehandSideLengths();
}

// --- Integrate SVG pad output with calculator ---
submitBtn.onclick = function() {
  // Calculate total sides from finished shapes and current drawing
  let totalSides = 0;
  let allSides = []; // Array to store all side data with direction vectors
  
  // Add sides from finished shapes
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    for(let k = 1; k < shape.length; k++) {
      const a = shape[k-1], b = shape[k];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const length = snapTo5mm((dx*dx)+(dy*dy));
      allSides.push({
        id: String.fromCharCode(65 + totalSides),
        length: length,
        dx: dx * MM_PER_PIXEL, // Convert to mm
        dy: dy * MM_PER_PIXEL  // Convert to mm
      });
      totalSides++;
    }
  }
  
  // Add sides from current drawing
  for(let k = 1; k < points.length; k++) {
    const a = points[k-1], b = points[k];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const length = snapTo5mm((dx*dx)+(dy*dy));
    allSides.push({
      id: String.fromCharCode(65 + totalSides),
      length: length,
      dx: dx * MM_PER_PIXEL, // Convert to mm
      dy: dy * MM_PER_PIXEL  // Convert to mm
    });
    totalSides++;
  }
  
  if(totalSides < 1) {
    alert('Please draw at least one side to create input fields.');
    return;
  }
  
  // Store the custom shape data globally for use by PDF and 3D systems
  window.customShapeData = {
    runs: allSides,
    isCustom: true
  };
  
  // Clear existing side inputs
  const sideInputsDiv = document.getElementById('sideInputs');
  sideInputsDiv.innerHTML = '';
  
  // Create dynamic side input boxes based on all drawn sides
  let sideInputsHTML = '<div class="grid">';
  
  for(let k = 0; k < totalSides; k++) {
    const sideData = allSides[k];
    const sideLetter = sideData.id;
    
    sideInputsHTML += `
      <div class="input-group">
        <label for="side${sideLetter}">Side ${sideLetter}:</label>
        <input type="number" id="side${sideLetter}" class="spanLen" value="${sideData.length}" min="100" max="6000" step="1">
        <span class="unit">mm</span>
      </div>
    `;
  }
  
  // Update spans array for calculation (keep backward compatibility)
  spans = allSides.map(s => s.length); // Use lengths for existing calculations
  
  sideInputsHTML += '</div>';
  sideInputsDiv.innerHTML = sideInputsHTML;
  
  // Ensure dropdowns are populated
  refreshSelectors();
  
  // Show success message
  const msg = document.createElement('div');
  msg.textContent = `✓ Created ${totalSides} side inputs from your drawing!`;
  msg.style.cssText = 'background:#d4edda;color:#155724;padding:10px;border-radius:5px;margin:10px 0;text-align:center;font-weight:bold;border:1px solid #c3e6cb;';
  sideInputsDiv.insertBefore(msg, sideInputsDiv.firstChild);
  setTimeout(() => msg.remove(), 4000);
};

// Function to handle resuming drawing from a specific point
function resumeDrawingFromPoint(pointIndex) {
  isDrawingMode = true;
  
  // Save the current shape as finished if it has at least 2 points
  if (points.length >= 2) {
    finishedShapes.push([...points]); // Save a copy of current points as finished shape
  }
  
  // Start a new drawing from the selected point
  const selectedPoint = points[pointIndex];
  points = [selectedPoint]; // Start new drawing with just the selected point
  
  currentDrawingPoint = selectedPoint;
  currentDrawingPointIndex = null; // Reset index since we're starting fresh
  updateUI();
  drawFreehandPad();
}

// Function to handle resuming drawing from a point in a finished shape
function resumeDrawingFromFinishedPoint(shapeIndex, pointIndex) {
  isDrawingMode = true;
  
  // Get the selected point from the finished shape
  const selectedPoint = finishedShapes[shapeIndex][pointIndex];
  
  // Save current points as finished if they exist
  if (points.length >= 2) {
    finishedShapes.push([...points]);
  }
  
  // Start new drawing from the selected finished point
  points = [selectedPoint];
  currentDrawingPoint = selectedPoint;
  currentDrawingPointIndex = null;
  updateUI();
  drawFreehandPad();
}

// Function to update UI based on drawing state
function updateUI() {
  if (isDrawingMode) {
    doneBtn.style.display = 'inline-block';
    editBtn.style.display = 'none';
    svgPad.style.cursor = 'crosshair';
  } else {
    doneBtn.style.display = 'none';
    editBtn.style.display = 'inline-block';
    svgPad.style.cursor = 'default';
  }
}

// Done button - stops drawing mode
doneBtn.onclick = () => {
  // Save state before making changes
  saveDrawingState();
  
  // Save current drawing as finished shape if it has at least 2 points (forms a line)
  if (points.length >= 2) {
    finishedShapes.push([...points]); // Save a copy of current points as finished shape
    points = []; // Clear current drawing
  }
  
  isDrawingMode = false;
  ghost = null; // Clear any ghost line
  currentDrawingPoint = null; // Clear drawing point
  updateUI();
  drawFreehandPad();
  updateFreehandSideLengths(); // Update measurements to include the newly finished shape
};

// Edit button - enables drawing mode
editBtn.onclick = () => {
  isDrawingMode = true;
  currentDrawingPoint = null; // Clear current drawing point so user must select one
  currentDrawingPointIndex = null; // Clear the drawing point index
  updateUI();
  drawFreehandPad();
};

clearBtn.onclick = clearSvgPad;

// Undo/Redo functionality
let drawingHistory = []; // Array to store drawing states
let historyIndex = -1; // Current position in history
const MAX_HISTORY = 50; // Maximum number of undo states to keep

// Save current drawing state to history
function saveDrawingState() {
  // Remove any future history if we're not at the end
  if (historyIndex < drawingHistory.length - 1) {
    drawingHistory = drawingHistory.slice(0, historyIndex + 1);
  }
  
  // Create a deep copy of the current state
  const state = {
    points: JSON.parse(JSON.stringify(points)),
    finishedShapes: JSON.parse(JSON.stringify(finishedShapes)),
    currentDrawingPoint: currentDrawingPoint ? {...currentDrawingPoint} : null,
    isDrawingMode: isDrawingMode
  };
  
  drawingHistory.push(state);
  historyIndex++;
  
  // Keep history within limits
  if (drawingHistory.length > MAX_HISTORY) {
    drawingHistory.shift();
    historyIndex--;
  }
  
  updateUndoRedoButtons();
}

// Restore drawing state from history
function restoreDrawingState(state) {
  points = JSON.parse(JSON.stringify(state.points));
  finishedShapes = JSON.parse(JSON.stringify(state.finishedShapes));
  currentDrawingPoint = state.currentDrawingPoint ? {...state.currentDrawingPoint} : null;
  isDrawingMode = state.isDrawingMode;
  ghost = null;
  
  drawFreehandPad();
  updateFreehandSideLengths();
  updateUI();
}

// Undo last action
function undoDrawing() {
  if (historyIndex > 0) {
    historyIndex--;
    restoreDrawingState(drawingHistory[historyIndex]);
    updateUndoRedoButtons();
  }
}

// Redo last undone action
function redoDrawing() {
  if (historyIndex < drawingHistory.length - 1) {
    historyIndex++;
    restoreDrawingState(drawingHistory[historyIndex]);
    updateUndoRedoButtons();
  }
}

// Update undo/redo button states
function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('svgUndoBtn');
  const redoBtn = document.getElementById('svgRedoBtn');
  
  if (undoBtn) {
    undoBtn.disabled = historyIndex <= 0;
    undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
  }
  
  if (redoBtn) {
    redoBtn.disabled = historyIndex >= drawingHistory.length - 1;
    redoBtn.style.opacity = historyIndex >= drawingHistory.length - 1 ? '0.5' : '1';
  }
}

// Add mouse wheel zoom functionality to SVG pad
svgPad.addEventListener('wheel', handleMouseWheel, { passive: false });

// Add pan functionality to SVG pad
svgPad.addEventListener('mousedown', handleMouseDown);
svgPad.addEventListener('mousemove', handleMouseMove);
svgPad.addEventListener('mouseup', handleMouseUp);

// Disable the onclick handler and replace with mousedown/mouseup for better control
// svgPad.onclick = ... (disabled)

// Better click handling with mousedown/mouseup
let mouseDownPoint = null;
let mouseDownTime = 0;

svgPad.addEventListener('mousedown', function(e) {
  if (e.ctrlKey || !isDrawingMode) return;
  if (e.button !== 0) return; // Only left mouse button
  
  mouseDownPoint = clientToSvg(e);
  mouseDownTime = Date.now();
});

svgPad.addEventListener('mouseup', function(e) {
  if (e.ctrlKey || !isDrawingMode) return;
  if (e.button !== 0) return; // Only left mouse button
  if (!mouseDownPoint) return;
  if (!currentDrawingPoint && points.length > 0) return;
  
  // Prevent multiple simultaneous clicks
  if (isProcessingClick) {
    mouseDownPoint = null;
    return;
  }
  
  // Prevent drawing if we were panning
  if (wasMouseMoved) {
    wasMouseMoved = false;
    mouseDownPoint = null;
    return;
  }
  
  const mouseUpPoint = clientToSvg(e);
  const clickDuration = Date.now() - mouseDownTime;
  
  // Ensure it was a quick click, not a drag
  const dragDistance = Math.sqrt(
    Math.pow(mouseUpPoint.x - mouseDownPoint.x, 2) + 
    Math.pow(mouseUpPoint.y - mouseDownPoint.y, 2)
  );
  
  if (dragDistance > 5 || clickDuration > 500) {
    mouseDownPoint = null;
    return; // Was a drag or too long a press
  }
  
  isProcessingClick = true;
  
  try {
    const now = Date.now();
    const newPoint = mouseUpPoint;
    
    // Prevent rapid successive clicks
    if (now - lastClickTime < DOUBLE_CLICK_THRESHOLD) {
      return;
    }
    
    // Prevent 0-length or very short lines
    if (currentDrawingPoint) {
      const distance = Math.sqrt(
        Math.pow(newPoint.x - currentDrawingPoint.x, 2) + 
        Math.pow(newPoint.y - currentDrawingPoint.y, 2)
      );
      
      if (distance < MIN_CLICK_DISTANCE) {
        return; // Too close to last point, ignore this click
      }
    }
    
    // Save state before drawing
    saveDrawingState();
    
    // Normal drawing - just add to end of current drawing
    points.push(newPoint);
    currentDrawingPoint = newPoint;
    ghost = null;
    drawFreehandPad();
    updateFreehandSideLengths();
    
    // Update click tracking
    lastClickTime = now;
    lastClickPoint = newPoint;
    
  } finally {
    mouseDownPoint = null;
    setTimeout(() => {
      isProcessingClick = false;
    }, 50);
  }
});

// Add SVG drawing event handlers

// Variables for improved click handling
let lastClickTime = 0;
let lastClickPoint = null;
let wasMouseMoved = false;
let isProcessingClick = false; // Prevent multiple simultaneous clicks
const MIN_CLICK_DISTANCE = 10; // Increased minimum distance in pixels
const DOUBLE_CLICK_THRESHOLD = 400; // Increased time threshold

// Convert screen coordinates to SVG coordinates accounting for zoom/pan
function clientToSvg(e) {
  const pt = svgPad.createSVGPoint();
  pt.x = e.clientX;
  pt.y = e.clientY;
  
  // Transform through the inverse of the SVG's screen transformation matrix
  const svgPoint = pt.matrixTransform(svgPad.getScreenCTM().inverse());
  
  return { x: svgPoint.x, y: svgPoint.y };
}

/*
// Old onclick handler - replaced with better mousedown/mouseup approach below
svgPad.onclick = function(e) {
  // Don't draw if Ctrl is held (navigation mode) or not in drawing mode
  if (e.ctrlKey || !isDrawingMode) return;
  if (!currentDrawingPoint && points.length > 0) return; // Must select a blue dot first if points exist
  
  // Prevent multiple simultaneous clicks
  if (isProcessingClick) {
    return;
  }
  
  // Prevent drawing if we were panning
  if (wasMouseMoved) {
    wasMouseMoved = false;
    return;
  }
  
  isProcessingClick = true;
  
  try {
    const now = Date.now();
    const newPoint = clientToSvg(e);
    
    // Prevent rapid successive clicks (double-clicking)
    if (now - lastClickTime < DOUBLE_CLICK_THRESHOLD) {
      return;
    }
    
    // Prevent 0-length or very short lines
    if (currentDrawingPoint) {
      const distance = Math.sqrt(
        Math.pow(newPoint.x - currentDrawingPoint.x, 2) + 
        Math.pow(newPoint.y - currentDrawingPoint.y, 2)
      );
      
      if (distance < MIN_CLICK_DISTANCE) {
        return; // Too close to last point, ignore this click
      }
    }
    
    // Save state before drawing
    saveDrawingState();
    
    // Normal drawing - just add to end of current drawing
    points.push(newPoint);
    currentDrawingPoint = newPoint; // Update current drawing point to the new point
    ghost = null;
    drawFreehandPad();
    updateFreehandSideLengths();
    
    // Update click tracking
    lastClickTime = now;
    lastClickPoint = newPoint;
    
  } finally {
    // Always release the processing lock, even if there was an error
    setTimeout(() => {
      isProcessingClick = false;
    }, 50);
  }
};
*/

svgPad.onmousemove = function(e) {
  // Don't show ghost line if Ctrl is held (navigation mode)
  if (e.ctrlKey) return;
  
  if(currentDrawingPoint && isDrawingMode) { // Only show ghost line when a drawing point is selected
    ghost = clientToSvg(e);
    drawFreehandPad();
  }
};

svgPad.onmouseleave = function() {
  ghost = null;
  drawFreehandPad();
};

// Add event listeners for undo/redo buttons
document.getElementById('svgUndoBtn').onclick = undoDrawing;
document.getElementById('svgRedoBtn').onclick = redoDrawing;

// Save initial state
saveDrawingState();

// Initialize the viewBox for zoom functionality
updateViewBox();

  </script>


<!-- Removed SP14 custom 3D viewer override; relying on existing 3D view implementation -->
</body>
</html>